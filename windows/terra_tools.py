# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Terra Tools
#                                  A QGIS plugin
#  This window has access to Tools for Terra/SCM application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """

from ..sensehawk_apis.core_apis import core_login, save_project_geojson, get_project_geojson
from ..sensehawk_apis.scm_apis import get_models_list, detect
from ..sensehawk_apis.terra_apis import get_terra_classmaps
from ..utils import categorize_layer
from ..event_filters import KeypressFilter, KeypressEmitter, KeypressShortcut, MousepressFilter
from ..tasks import clipRequest, detectionTask, approveTask

from ..constants import STORAGE_PRIVATE_KEY

from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsMessageLog, Qgis, QgsApplication, QgsTask, QgsFeatureRequest, QgsPoint
from qgis.PyQt.QtCore import Qt
import os
from threading import Thread
from qgis.gui import QgsMapToolEmitPoint
import qgis

from qgis.utils import iface

from PyQt5.QtGui import QCursor
from PyQt5.QtWidgets import QApplication

import json
import copy


TERRA_TOOLS_UI, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'terra_tools.ui'))


class TerraToolsWindow(QtWidgets.QDockWidget, TERRA_TOOLS_UI):

    def __init__(self, load_window, iface):
        """Constructor."""
        super(TerraToolsWindow, self).__init__()
        self.setupUi(self)
        self.backButton.clicked.connect(self.show_load_window)
        self.loadModelsButton.clicked.connect(self.load_models)
        self.detectButton.clicked.connect(self.start_detect_task)
        self.approveButton.clicked.connect(self.start_approve_task)
        self.clipButton.clicked.connect(self.start_clip_task)
        self.saveProject.clicked.connect(self.save_project)
        self.load_window = load_window
        self.core_token = self.load_window.core_token
        self.project_details = self.load_window.project_details
        self.class_maps = self.load_window.class_maps
        self.iface = iface
        self.canvas = self.iface.mapCanvas()
        self.active_layer = self.iface.activeLayer()
        # Add to the left docking area by default
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self)
        self.models_dict = {}
        ## Keyboard shortcuts
        self.keyboard_shortcuts = {}
        # Create the feature change shortcuts for this particular project using class maps
        self.create_feature_change_shortcuts()
        # Create QGIS tools shortcuts
        self.create_qgis_shortcuts()
        # Create a key emitter that sends the key presses
        self.key_emitter = KeypressEmitter()
        # Connect the key emitter to the key eater that performs required shortcuts
        self.key_emitter.signal.connect(lambda x: self.key_eater(x))
        # Create keypress event filter to consume the key presses from iface and send it to key_emitter
        self.keypress_filter = KeypressFilter(self.key_emitter)
        # Install key press filter to iface's map canvas
        self.iface.mapCanvas().installEventFilter(self.keypress_filter)

        # Mouse press filter
        self.mouse_emitter = KeypressEmitter()
        self.mousepress_filter = MousepressFilter(self.mouse_emitter)
        self.pointTool = QgsMapToolEmitPoint(self.iface.mapCanvas())

    def logger(self, message, level=Qgis.Info):
        QgsMessageLog.logMessage(message, 'SenseHawk QC', level=level)

    def show_load_window(self):
        self.load_window.terra_tools_window = self
        self.load_window.show()
        self.hide()

    def load_models(self):
        # Get list of available models
        self.models_dict = get_models_list(self.load_window.project_uid)
        models_list = list(self.models_dict.keys())
        if models_list:
            list_items = models_list
        else:
            list_items = ["No models available"]
        # Clear list to avoid duplicates
        self.detectionModel.clear()
        self.detectionModel.addItems(list_items)

    def add_feature(self):
        layer = self.iface.activeLayer()
        if not isinstance(layer, qgis._core.QgsVectorLayer):
            self.logger("Select a vector layer to add feature...")
            return None
        layer.startEditing()
        self.iface.actionAddFeature().trigger()

    # Shortcut
    def save_layer(self):
        layer = self.iface.activeLayer()
        if not isinstance(layer, qgis._core.QgsVectorLayer):
            return None
        # Deselect any selected features
        layer.removeSelection()
        layer.commitChanges()
        # In case duplicate feature was activated, disconnect copy-in-place on left mouse click
        try:
            self.mouse_emitter.signal.disconnect()
            self.iface.mapCanvas().viewport().removeEventFilter(self.mousepress_filter)
        except Exception:
            pass
        categorize_layer(self.class_maps)

    def start_clip_task(self):
        clip_task = clipRequest(self.logger, self.project_details, self.load_window.geojson_path, self.class_maps)
        QgsApplication.taskManager().addTask(clip_task)

    def start_detect_task(self):
        def callback(task, logger):
            result = task.returned_values
            if result:
                logger(str(result))
        self.logger("Detection called..")
        geojson = get_project_geojson(self.project_details.get("uid", None), self.core_token, "terra")
        self.logger("Getting model information...")
        model_name = self.detectionModel.currentText()
        if model_name not in self.models_dict:
            self.logger("Invalid model...")
            return None
        model_url = self.models_dict[model_name]
        self.logger("Initiating detection request task...")
        detection_task = QgsTask.fromFunction("Detect", detectionTask,
                                              detection_task_input=[self.project_details, geojson,
                                                                    model_url, self.load_window.user_email])
        detection_task.statusChanged.connect(lambda:callback(detection_task, self.logger))
        QgsApplication.taskManager().addTask(detection_task)

    def start_approve_task(self):
        def callback(task, logger):
            result = task.returned_values
            if result:
                logger(str(result))
        self.logger("Approve called...")
        geojson = get_project_geojson(self.project_details.get("uid", None), self.core_token, "terra")
        approve_task = QgsTask.fromFunction("Approve", approveTask,
                                            approve_task_input=[self.project_details, geojson,
                                                                self.load_window.user_email])
        approve_task.statusChanged.connect(lambda:callback(approve_task, self.logger))
        QgsApplication.taskManager().addTask(approve_task)

    # Shortcut function
    def change_feature_type(self, class_name):
        layer = self.iface.activeLayer()
        if not isinstance(layer, qgis._core.QgsVectorLayer):
            self.logger("Activate a vector layer or select feature to change feature type...")
            return None
        layer.startEditing()
        # If there are selected items, change feature type for those or else change feature type of last added feature
        selected_features = list(layer.selectedFeatures())
        if selected_features:
            for feature in selected_features:
                feature.setAttribute("class_name", class_name)
                class_id = self.class_maps.get(class_name, {}).get("id", None)
                feature.setAttribute("class_id", int(class_id))
                layer.updateFeature(feature)
        else:
            features = list(layer.getFeatures())
            last_feature_index = -1
            try:
                last_feature = features[last_feature_index]
            except IndexError:
                self.logger("No feature selected or new feature added...")
                return None
            self.logger("Changing class_name of last added feature to {}".format(class_name))
            last_feature.setAttribute("class_name", class_name)
            class_id = self.class_maps.get(class_name, {}).get("id", None)
            last_feature.setAttribute("class_id", int(class_id))
            layer.updateFeature(last_feature)
        categorize_layer(self.class_maps)

    def create_feature_change_shortcuts(self):
        # Populate shortcuts dictionary for feature type change with keys
        shortcuts_dict = {self.class_maps[i]["name"]: {"key": None,
                                                       "class_name": i,
                                                       "key_code": None,
                                                       "name": self.class_maps[i]["name"],
                                                       "function": self.change_feature_type,
                                                       "function_args": [i, ],
                                                       "shortcut_type": "Feature type change"} for i in self.class_maps}
        shortcuts_dict.get("clip_boundary", {})["key"] = "C"
        shortcuts_dict.get("train_boundary", {})["key"] = "T"
        # We will give shortcuts to other classes starting from 1 in alphabetical order
        count = 1
        remaining_classes = sorted([i for i in shortcuts_dict if not shortcuts_dict[i]["key"]])
        for c in remaining_classes:
            shortcuts_dict[c]["key"] = str(count)
            count += 1
        # Generate keycode which is communicated from keyboard
        for s in shortcuts_dict:
            key = shortcuts_dict[s]["key"]
            key_code = eval("Qt.Key_{}".format(key.upper()))
            shortcuts_dict[s]["key_code"] = key_code

        for i in shortcuts_dict:
            self.keyboard_shortcuts[shortcuts_dict[i]["key_code"]] = KeypressShortcut(shortcuts_dict[i])

    def duplicate_feature(self):
        # Install mouse press filter to iface's map canvas
        self.iface.mapCanvas().viewport().installEventFilter(self.mousepress_filter)
        move_function = self.iface.actionMoveFeature()
        move_function.trigger()
        # Connect mouse event to copy in place function
        self.mouse_emitter.signal.connect(lambda mouse_event: copy_in_place(mouse_event))
        def copy_in_place(mouse_event):
            mouse_button = mouse_event.button()
            point = self.canvas.getCoordinateTransform().toMapCoordinates(mouse_event.pos())
            x, y = point.x(), point.y()
            if mouse_button == 1:
                # If anything is selected, deselect and do nothing else
                if self.active_layer.selectedFeatures():
                    self.active_layer.removeSelection()
                    return None

                # Left button repeats function if nothing is selected currently
                feature_request = QgsFeatureRequest()
                feature_request.setFilterRect(QgsPoint(x, y).boundingBox())
                features = self.active_layer.getFeatures(feature_request)
                # Sort features by area and select the least area feature for copy and move
                features = sorted([f for f in features], key=lambda f: f.geometry().area())
                if not features:
                    self.active_layer.removeSelection()
                    return False
                selected_feature = features[0]
                f_id = selected_feature.id()
                self.active_layer.selectByIds([f_id])
                self.iface.actionCopyFeatures().trigger()
                self.iface.actionPasteFeatures().trigger()

    def create_qgis_shortcuts(self):
        # 'Enter' key saves the active layer
        self.keyboard_shortcuts[16777220] = KeypressShortcut({"key_code": 16777220,
                                                              "name": "Save layer changes",
                                                              "function": self.save_layer,
                                                              "shortcut_type": "QGIS tools"})
        # 'S' key for select feature
        self.keyboard_shortcuts[83] = KeypressShortcut({"key_code": 83,
                                                        "name": "Select features",
                                                        "function": self.iface.actionSelect().trigger,
                                                        "shortcut_type": "QGIS tools"})
        # 'F' key to add new feature
        self.keyboard_shortcuts[70] = KeypressShortcut({"key_code": 70,
                                                        "name": "Add new feature",
                                                        "function": self.add_feature,
                                                        "shortcut_type": "QGIS tools"})
        # 'P' key to change feature properties / show attributes table
        self.keyboard_shortcuts[80] = KeypressShortcut({"key_code": 80,
                                                        "name": "Show attribute table",
                                                        "function": "iface.showAttributeTable(iface.activeLayer())",
                                                        "shortcut_type": "QGIS tools"})
        # 'E' key to toggle editing of selected layer
        self.keyboard_shortcuts[69] = KeypressShortcut({"key_code": 69,
                                                        "name": "Toggle selected layer edit",
                                                        "function": "iface.showAttributeTable(iface.activeLayer())",
                                                        "shortcut_type": "QGIS tools"})

        # 'Z' key to zoom to layer
        self.keyboard_shortcuts[90] = KeypressShortcut({"key_code": 90,
                                                        "name": "Zoom to layer",
                                                        "function": self.iface.actionZoomToLayer().trigger,
                                                        "shortcut_type": "QGIS tools"})

        # 'D' key to duplicate feature
        self.keyboard_shortcuts[68] = KeypressShortcut({"key_code": 68,
                                                        "name": "Duplicate feature",
                                                        "function": self.duplicate_feature,
                                                        "shortcut_type": "QGIS tools"})


    def key_eater(self, key_code):
        # Is connected to the keyboard and will call the relevant functions from the shortcuts_dict when a key is pressed
        shortcut = self.keyboard_shortcuts.get(key_code, None)
        if not shortcut:
            return None
        self.logger("Keyboard shortcut: {}".format(shortcut.name))
        shortcut.run()

    def save_project(self):
        if self.load_window.load_successful:
            self.logger("Saving following geojson: "+str(self.load_window.geojson_path))
            geojson_path = self.load_window.geojson_path
            cleaned_geojson_path = geojson_path.replace(".geojson", "_cleaned.geojson")
            # Delete any duplicate features
            qgis.processing.run('qgis:deleteduplicategeometries',
                                {"INPUT": geojson_path, "OUTPUT": cleaned_geojson_path})
            geojson = json.load(open(cleaned_geojson_path))
            if self.load_window.project_type == "terra":
                for f in geojson["features"]:
                    f["properties"]["workflow"] = {}
                    if not f["properties"]["class_id"]:
                        f["properties"]["class_id"] = 0
            # Upload vectors
            self.logger('Saving SenseHawk project...')
            saved = save_project_geojson(geojson, self.load_window.project_uid, self.core_token, project_type=self.load_window.project_type)
            if saved:
                self.logger(str(saved))
            else:
                self.logger("Save failed", Qgis.Warning)



