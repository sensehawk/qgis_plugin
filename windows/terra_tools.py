# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Terra Tools
#                                  A QGIS plugin
#  This window has access to Tools for Terra/SCM application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """

from ..sensehawk_apis.core_apis import core_login, save_project_geojson
from ..sensehawk_apis.scm_apis import get_models_list, clip_request
from ..sensehawk_apis.terra_apis import get_terra_classmaps
from ..utils import categorize_layer, combined_geojson
from ..event_filters import KeypressFilter, KeypressEmitter, KeypressShortcut

from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsMessageLog, Qgis
from qgis.PyQt.QtCore import Qt
import os
from threading import Thread
from qgis.gui import QgsMapToolEmitPoint
import qgis

from qgis.utils import iface


TERRA_TOOLS_UI, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'terra_tools.ui'))


class TerraToolsWindow(QtWidgets.QDockWidget, TERRA_TOOLS_UI):

    def __init__(self, load_window, iface):
        """Constructor."""
        super(TerraToolsWindow, self).__init__()
        self.setupUi(self)
        self.backButton.clicked.connect(self.show_load_window)
        self.loadModelsButton.clicked.connect(self.load_models)
        self.clipButton.clicked.connect(self.clip)
        self.saveProject.clicked.connect(self.save_project)
        self.load_window = load_window
        self.core_token = self.load_window.core_token
        self.project_details = self.load_window.project_details
        self.class_maps = self.load_window.class_maps
        self.iface = iface
        # Add to the left docking area by default
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self)

        self.models_dict = {}

        ## Keyboard shortcuts
        self.keyboard_shortcuts = {}
        # Create the feature change shortcuts for this particular project using class maps
        self.create_feature_change_shortcuts()
        # Create QGIS tools shortcuts
        self.create_qgis_shortcuts()
        # Create a key emitter that sends the key presses
        self.key_emitter = KeypressEmitter()
        # Connect the key emitter to the key eater that performs required shortcuts
        self.key_emitter.signal.connect(lambda x: self.key_eater(x))
        # Create keypress event filter to consume the key presses from iface and send it to key_emitter
        self.keypress_filter = KeypressFilter(self.key_emitter)
        # Install key press filter to iface's map canvas
        self.iface.mapCanvas().installEventFilter(self.keypress_filter)

    def logger(self, message, level=Qgis.Info):
        QgsMessageLog.logMessage(message, 'SenseHawk QC', level=level)

    def show_load_window(self):
        self.load_window.terra_tools_window = self
        self.load_window.show()
        self.hide()

    def load_models(self):
        # Get list of available models
        self.models_dict = get_models_list(self.load_window.project_uid)
        models_list = list(self.models_dict.keys())
        if models_list:
            list_items = ["Select detection model..."] + models_list
        else:
            list_items = ["No models available..."]
        # Clear list to avoid duplicates
        self.detectionModel.clear()
        self.detectionModel.addItems(list_items)

    def add_feature(self):
        layer = self.iface.activeLayer()
        if not isinstance(layer, qgis._core.QgsVectorLayer):
            self.logger("Select a vector layer to add feature...")
            return None
        layer.startEditing()
        self.iface.actionAddFeature().trigger()

    # Shortcut
    def save_layer(self):
        layer = self.iface.activeLayer()
        layer.commitChanges()
        categorize_layer(self.class_maps)

    def clip(self):
        clip_boundary_class_name = None
        # Get the class_name for clip_boundary
        for i in self.class_maps.items():
            if i[1].get("name") == "clip_boundary":
                clip_boundary_class_name = i[0]
        if not clip_boundary_class_name:
            self.logger("Please add clip_boundary feature type in Terra...", level=Qgis.Warning)
            return None
        geojson = combined_geojson(self.load_window.geojson_paths)
        all_clip_feature_names = []
        for f in geojson["features"]:
            properties = f["properties"]
            if properties["class_name"] == clip_boundary_class_name:
                name = properties.get("name", None)
                all_clip_feature_names.append(name)
        n_clip_features = len(all_clip_feature_names)
        n_unique_clip_names = len(list(set(all_clip_feature_names)))
        # If there are no unique clip feature names or if any of them has None
        if n_clip_features != n_unique_clip_names or None in all_clip_feature_names:
            self.logger("Please provide unique name property to all clip_boundary features before clipping...", level=Qgis.Warning)
            return None
        clip_request(self.logger, self.project_details, geojson, clip_boundary_class_name)

    # Shortcut function
    def change_feature_type(self, class_name):
        layer = self.iface.activeLayer()
        # If there are selected items, change feature type for those or else change feature type of last added feature
        selected_features = list(layer.selectedFeatures())
        if selected_features:
            for feature in selected_features:
                feature.setAttribute("class_name", class_name)
                class_id = self.class_maps.get(class_name, {}).get("id", None)
                feature.setAttribute("class_id", int(class_id))
                layer.updateFeature(feature)
        else:
            features = list(layer.getFeatures())
            last_feature_index = -1
            try:
                last_feature = features[last_feature_index]
            except IndexError:
                self.logger("No feature selected or new feature added...")
                return None
            self.logger("Changing class_name of last added feature to {}".format(class_name))
            last_feature.setAttribute("class_name", class_name)
            class_id = self.class_maps.get(class_name, {}).get("id", None)
            last_feature.setAttribute("class_id", int(class_id))
            layer.updateFeature(last_feature)
        categorize_layer(self.class_maps)

    def create_feature_change_shortcuts(self):
        # Populate shortcuts dictionary for feature type change with keys
        shortcuts_dict = {self.class_maps[i]["name"]: {"key": None,
                                                       "class_name": i,
                                                       "key_code": None,
                                                       "name": self.class_maps[i]["name"],
                                                       "function": self.change_feature_type,
                                                       "function_args": [i, ],
                                                       "shortcut_type": "Feature type change"} for i in self.class_maps}
        shortcuts_dict.get("clip_boundary", {})["key"] = "C"
        shortcuts_dict.get("train_boundary", {})["key"] = "T"
        # We will give shortcuts to other classes starting from 1 in alphabetical order
        count = 1
        remaining_classes = sorted([i for i in shortcuts_dict if not shortcuts_dict[i]["key"]])
        for c in remaining_classes:
            shortcuts_dict[c]["key"] = str(count)
            count += 1
        # Generate keycode which is communicated from keyboard
        for s in shortcuts_dict:
            key = shortcuts_dict[s]["key"]
            key_code = eval("Qt.Key_{}".format(key.upper()))
            shortcuts_dict[s]["key_code"] = key_code

        for i in shortcuts_dict:
            self.keyboard_shortcuts[shortcuts_dict[i]["key_code"]] = KeypressShortcut(shortcuts_dict[i])

    def create_qgis_shortcuts(self):
        # 'Enter' key saves the active layer
        self.keyboard_shortcuts[16777220] = KeypressShortcut({"key_code": 16777220,
                                                              "name": "Save layer changes",
                                                              "function": self.save_layer,
                                                              "shortcut_type": "QGIS tools"})
        # 'S' key for select feature
        self.keyboard_shortcuts[83] = KeypressShortcut({"key_code": 83,
                                                        "name": "Select features",
                                                        "function": self.iface.actionSelect().trigger,
                                                        "shortcut_type": "QGIS tools"})
        # 'F' key to add new feature
        self.keyboard_shortcuts[70] = KeypressShortcut({"key_code": 70,
                                                        "name": "Add new feature",
                                                        "function": self.add_feature,
                                                        "shortcut_type": "QGIS tools"})
        # 'P' key to change feature properties / show attributes table
        self.keyboard_shortcuts[80] = KeypressShortcut({"key_code": 80,
                                                        "name": "Show attribute table",
                                                        "function": "iface.showAttributeTable(iface.activeLayer())",
                                                        "shortcut_type": "QGIS tools"})

    def key_eater(self, key_code):
        # Is connected to the keyboard and will call the relevant functions from the shortcuts_dict when a key is pressed
        shortcut = self.keyboard_shortcuts.get(key_code, None)
        if not shortcut:
            return None
        self.logger("Keyboard shortcut: {}".format(shortcut.name))
        shortcut.run()

    def save_project(self):
        if self.load_window.load_successful:
            self.logger("Combining following geojsons: "+str(self.load_window.geojson_paths))
            # Combine all geojsons that were split when loading
            geojson = combined_geojson(self.load_window.geojson_paths)
            # Upload vectors
            self.logger('Saving SenseHawk project...')
            saved = save_project_geojson(geojson, self.load_window.project_uid, self.core_token, project_type=self.load_window.project_type)
            if saved:
                self.logger("Save successful...")
            else:
                self.logger("Save failed...", Qgis.Warning)



