# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Terra Tools
#                                  A QGIS plugin
#  This window has access to Tools for Terra/SCM application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """

from ..sensehawk_apis.core_apis import get_project_geojson
from ..utils import features_to_polygons
from ..tasks import clip_request
from functools import partial

from qgis.core import Qgis, QgsApplication, QgsTask  
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsProject
from PyQt5 import QtCore

import traceback
import requests
import json
import os


class TerraToolsWidget(QtWidgets.QWidget):
    def __init__(self, project):
        """Constructor."""
        super(TerraToolsWidget, self).__init__()
        uic.loadUi(os.path.join(os.path.dirname(__file__), 'terra_tools.ui'), self)
        self.project = project
        self.parent = self.project.project_tab
        self.canvas_logger = project.canvas_logger
        self.logger = project.logger
        self.train_model.clicked.connect(self.model_train)
        self.detect_button.clicked.connect(lambda : DetectComponent(self))
        # self.approveButton.clicked.connect(self.start_approve_task)
        # self.clipButton.clicked.connect(self.start_clip_task)
        self.report_update.clicked.connect(lambda: Report_and_update(self))
        self.orderComponent.clicked.connect(lambda: ComponentPreProcess(self))
        self.core_token = self.project.core_token
        self.project_details = self.project.project_details
        self.class_maps = self.project.class_maps
        self.class_groups = self.project.class_groups
        self.iface = self.project.iface
        self.active_layer = self.project.vlayer
        self.models_dict = {}
        self.components_ordered_info = {}
        self.componentOrdered = False
        # ML Service Map
        self.ml_service_map_widget = None
        

    def uncheck_all_buttons(self):
        for button in self.findChildren(QtWidgets.QPushButton):
            if button.isCheckable():
                button.setChecked(False)

    def model_train(self):
        url = "https://pyufpjfyiw3sbmpte5sb2ta7gy0aedkg.lambda-url.us-west-2.on.aws/"
        headers = {"Authorization": "Token {}".format(self.core_token)} 
        endpoint = "train"
        service_name = "scmv4"
        params = {
                "service_name":service_name, "email_id": self.project.user_email,"endpoint":endpoint, 
                "org_uid":self.project_details['organization']['uid'], "project_uid":self.project_details.get('uid', None)
                }
        print(params, headers)
        resp = requests.post(url, headers=headers, params=params)
        self.canvas_logger(f"{resp.json()}")

    def start_clip_task(self):
        def callback(task, logger):
            result = task.returned_values
            if result:
                logger(str(result["message"]))

        self.logger("Clip task starting...")
        self.uncheck_all_buttons()
        clip_task_inputs = self.logger, self.project_details, self.load_window.geojson_path, self.class_maps, self.core_token
        clip_task = QgsTask.fromFunction("Clip Request", clip_request, clip_task_input=clip_task_inputs)
        clip_task.statusChanged.connect(lambda: callback(clip_task, self.logger))
        QgsApplication.taskManager().addTask(clip_task)


    # def start_approve_task(self):
    #     def callback(task, logger):
    #         result = task.returned_values
    #         if result:
    #             logger(str(result))

    #     self.logger("Approve called...")
    #     self.uncheck_all_buttons()
    #     geojson = get_project_geojson(self.project_details.get("uid", None), self.core_token, "terra")
    #     approve_task = QgsTask.fromFunction("Approve", approveTask,
    #                                         approve_task_input=[self.project_details, geojson,
    #                                                             self.project.user_email,
    #                                                             self.core_token])
    #     QgsApplication.taskManager().addTask(approve_task)
    #     approve_task.statusChanged.connect(lambda: callback(approve_task, self.logger))

    def loadInferaCallback(self, task_status, loadInfereJsonTask):
        if task_status != 3:
            return None
        result = loadInfereJsonTask.returned_values
        if result:
            response = result['response']
            existing_geojson = result['existing_geojson']
            if response.status_code == 200:
                #disconnect any single added to existing vlayer
                self.project.vlayer.selectionChanged.disconnect()
                # Remove existing Vlayer  
                self.project.qgis_project.removeMapLayers([self.project.vlayer.id()])
                #saving merged geojson
                with open(self.project.geojson_path, "w") as fi:
                    json.dump(existing_geojson, fi)
                self.project.initialize_vlayer()
                self.canvas_logger('Components features loaded', level=Qgis.Success)
            
            else:
                self.canvas_logger(str(response.json()+'|'+response.status_code), level=Qgis.Warning)


class DetectComponent(QtWidgets.QDialog):
    def __init__(self, terra_obj):
        super(DetectComponent, self).__init__()
        self.terra_obj = terra_obj
        self.setWindowTitle("Detect Component")
        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        layout = QtWidgets.QVBoxLayout(self)
        self.load_model = uic.loadUi(os.path.join(os.path.dirname(__file__), 'load_model.ui'))
        self.load_model.detection_model_cbox.currentTextChanged.connect(self.detection_model_cbox_fn)
        button_box = QtWidgets.QDialogButtonBox()
        button_box.addButton("DETECT", QtWidgets.QDialogButtonBox.AcceptRole)
        button_box.addButton("Cancel", QtWidgets.QDialogButtonBox.RejectRole)
        button_box.accepted.connect(self.detect_task)
        button_box.rejected.connect(self.close_dialogbox)
        button_box.setCenterButtons(True)
        # layout.addLayout(hlayout)
        layout.addWidget(self.load_model)
        layout.addWidget(button_box)
        self.setup_ui()
        self.exec_()
    
    def setup_ui(self):
        # Get list of available models
        #TODO endpoint to fetch run details
        self.get_assetlevel_model_details = self.get_assetlevel_model()
        models_list = list(self.get_assetlevel_model_details.keys())
        if models_list:
            list_items = models_list
        else:
            list_items = ["No models available"]
        self.terra_obj.uncheck_all_buttons()
        # Clear list to avoid duplicates
        self.load_model.detection_model_cbox.clear()
        self.load_model.detection_model_cbox.addItems(list_items)

    def get_assetlevel_model(self):
        url = "http://mlflow.sensehawk.com:8080/get_runs"
        asset_uid = self.terra_obj.project_details["asset"]["uid"]
        params = {"asset_uid": asset_uid}
        print(self.terra_obj.project_details)
        resp = requests.get(url, params=params)
        run_details = resp.json()
        print(run_details)
        return run_details
    
    def detection_model_cbox_fn(self, model):
        model_info = self.get_assetlevel_model_details[model]
        self.load_model.components_label.setText(model_info[4])

    def detect_task(self):
        self.accept()
        url = "https://pyufpjfyiw3sbmpte5sb2ta7gy0aedkg.lambda-url.us-west-2.on.aws/"
        headers = {"Authorization": "Token {}".format(self.terra_obj.core_token)} 
        endpoint = "inference"
        service_name = "scmv4"
        project_run_uid = self.load_model.detection_model_cbox.currentText()
        params = {
                "service_name":service_name, "email_id": self.terra_obj.project.user_email,"endpoint":endpoint, 
                "org_uid":self.terra_obj.project_details['organization']['uid'], "project_run_uid": project_run_uid,
                "project_uid":self.terra_obj.project_details.get('uid', None)
                }
        print(params, headers)
        resp = requests.post(url, headers=headers, params=params)
        self.terra_obj.canvas_logger(f"{resp.json()}")

    def close_dialogbox(self):
        self.reject()

class ComponentPreProcess(QtWidgets.QDialog):
    def __init__(self, terra_obj):
        super(ComponentPreProcess, self).__init__()
        self.terra_obj = terra_obj
        self.setWindowTitle("Component Pre Process")
        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        layout = QtWidgets.QVBoxLayout(self)
        self.component_pre_process_ui = uic.loadUi(os.path.join(os.path.dirname(__file__), 'sdp_component_header.ui'))
        button_box = QtWidgets.QDialogButtonBox()
        button_box.addButton("RUN", QtWidgets.QDialogButtonBox.AcceptRole)
        button_box.addButton("Cancel", QtWidgets.QDialogButtonBox.RejectRole)
        button_box.accepted.connect(self.pre_process)
        button_box.rejected.connect(self.close_dialogbox)
        button_box.setCenterButtons(True)
        layout.addWidget(self.component_pre_process_ui)
        layout.addWidget(button_box)
        self.workflow_id = None
        self.worflowProgress = None
        self.component_names = None
        self.component_widgets_list = []
        self.extraproperties_info = None
        self.component_order_num = 1
        self.setup_ui()
        if self.component_names:
            self.exec_()

    def setup_ui(self):
        vlayer = self.terra_obj.project.vlayer
        for feat in vlayer.getFeatures():
            if feat['workflow'] and feat['workflowProgress']:
                self.workflow_id = feat['workflow']
                self.worflowProgress = feat['workflowProgress']
                self.component_names = list(feat["extraProperties"]["component"].keys())
                self.extraproperties_info = feat["extraProperties"]
                break
                                
        if not self.component_names:
            self.terra_obj.canvas_logger('component info not found', level=Qgis.Warning)
            return None
        else:
            for component in self.component_names:
                comp_assoc_ui = uic.loadUi(os.path.join(os.path.dirname(__file__), 'sdp_comp_order_assoc.ui'))
                comp_assoc_ui.component_btn.setText(component)
                comp_assoc_ui.component_btn.clicked.connect(partial(self.prepare_data, comp_assoc_ui))
                comp_assoc_ui.target_box.addItems(self.extraproperties_info)
                self.component_pre_process_ui.compenent_order_vlayout.addWidget(comp_assoc_ui)
                self.component_widgets_list.append(comp_assoc_ui)

    def prepare_data(self, widget):
        self.update_order(widget)

    def update_order(self, widget):
        if self.component_order_num > len(self.component_names):
            self.component_order_num = 1
            order_num = self.component_order_num
        else:
            order_num = self.component_order_num

        widget.order_num.setText(str(order_num))
        self.component_order_num += 1

    def pre_process(self):
        self.accept()
        for component_widget in self.component_widgets_list:
            comp_name = component_widget.component_btn.text()
            print(comp_name)
            print(self.terra_obj.components_ordered_info)
            print(component_widget.order_num.text())
            print(component_widget.target_box.currentText())
            self.terra_obj.components_ordered_info[comp_name] = {"order_index": int(component_widget.order_num.text()),
                                                                 "target_value": component_widget.target_box.currentText()}
        self.terra_obj.components_ordered_info = sorted(self.terra_obj.components_ordered_info.items(),
                                                        key=lambda x: x[1]["order_index"])
        self.terra_obj.componentOrdered = True
        # pprint.pprint(self.terra_obj.components_ordered_info)

    def close_dialogbox(self):
        self.reject()


class Report_and_update(QtWidgets.QDialog):
    def __init__(self, terra_obj):
        super(Report_and_update, self).__init__()
        self.terra_obj = terra_obj
        self.setWindowTitle("Assign Container")
        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        layout = QtWidgets.QVBoxLayout(self)
        self.scm_classification_ui = uic.loadUi(os.path.join(os.path.dirname(__file__), 'scm_classification.ui'))
        button_box = QtWidgets.QDialogButtonBox()
        button_box.addButton("RUN", QtWidgets.QDialogButtonBox.AcceptRole)
        button_box.addButton("Cancel", QtWidgets.QDialogButtonBox.RejectRole)
        button_box.accepted.connect(self.run_classification)
        button_box.rejected.connect(self.close_dialogbox)
        button_box.setCenterButtons(True)
        layout.addWidget(self.scm_classification_ui)
        layout.addWidget(button_box)
        self.workflow_id = None
        self.worflowProgress = None
        self.current_position = 2
        self.extraproperties = None
        self.extraproperties_info = None
        if terra_obj.componentOrdered:
            self.setup_ui()
            self.exec_()
        else:
            self.terra_obj.canvas_logger("Order Component before Generating reports")

    def setup_ui(self):
        vlayer = self.terra_obj.project.vlayer
        for feat in vlayer.getFeatures():
            if feat['workflow'] and feat['workflowProgress']:
                self.workflow_id = feat['workflow']
                self.worflowProgress = feat['workflowProgress']
                self.extraproperties = list(feat["extraProperties"]["component"].keys())
                self.extraproperties_info = feat["extraProperties"]
                break

        headers = {'Authorization': f'Token {self.terra_obj.project.core_token}'}
        url = f"https://terra-server.sensehawk.com/workflows/{self.workflow_id}/?organization={self.terra_obj.project_details['organization']['uid']}"
        workflow_response = requests.get(url, headers=headers)
        # print(workflow_response.status_code)
        # print(workflow_response.json())
        # print(self.terra_obj.project.feature_count_dict)
        print(self.terra_obj.project.class_maps)

        class_maps = self.terra_obj.project.class_maps
        associated_workflow_info = workflow_response.json()['data']

        mapped_class_map = {}
        for feature_type in class_maps:
            uid = class_maps[feature_type].get("uid")
            mapped_class_map[uid] = feature_type

        self.workflow_detail_info = {}
        for feature_id, workflow_info in associated_workflow_info.items():
            class_name = mapped_class_map[feature_id]
            workflow_info["current_feat_name"] = class_name
            destination_uid = workflow_info["destination"]
            workflows = workflow_info["fields"]
            workflow_info['destination_feat_name'] = mapped_class_map[destination_uid]
            workflow_info["destination_feat_class_id"] = self.terra_obj.project.class_maps[class_name].get('id', None)

            currt_feature_type = QtWidgets.QLabel(mapped_class_map[feature_id])
            dest_feature_type = QtWidgets.QLabel(mapped_class_map[destination_uid])
            vlayout = QtWidgets.QVBoxLayout()
            self.scm_classification_ui.feature_gridlayout.addWidget(currt_feature_type, self.current_position, 0)
            self.scm_classification_ui.feature_gridlayout.addWidget(dest_feature_type, self.current_position, 2)

            for workflow in workflows:
                wrk_name = workflow["name"]
                uid = workflow["uid"]
                component_info_ui = uic.loadUi(os.path.join(os.path.dirname(__file__), 'workflow_component_assoc.ui'))
                component_info_ui.component_box.addItems(self.extraproperties)
                component_info_ui.wrkflow_name.setText(f'Workflow Name: {wrk_name}')
                vlayout.addWidget(component_info_ui)
                workflow['component_ui'] = component_info_ui
                # workflow['component_total_count'] = self.worflowProgress[uid]["total"]

            self.workflow_detail_info[feature_id] = workflow_info
            self.scm_classification_ui.feature_gridlayout.addLayout(vlayout, self.current_position, 1)
            self.current_position += 1
            line1 = QtWidgets.QFrame()
            line1.setFrameShape(QtWidgets.QFrame.HLine)
            line2 = QtWidgets.QFrame()
            line2.setFrameShape(QtWidgets.QFrame.HLine)
            line3 = QtWidgets.QFrame()
            line3.setFrameShape(QtWidgets.QFrame.HLine)
            self.scm_classification_ui.feature_gridlayout.addWidget(line1, self.current_position, 0)
            self.scm_classification_ui.feature_gridlayout.addWidget(line2, self.current_position, 1)
            self.scm_classification_ui.feature_gridlayout.addWidget(line3, self.current_position, 2)
            self.current_position += 1

    def run_classification(self):
        self.accept()
        for feature, workflow_info in self.workflow_detail_info.items():
            for workflow in workflow_info["fields"]:
                workflow["component_name"] = workflow["component_ui"].component_box.currentText()

        # pprint.pprint(self.workflow_detail_info)

        def check_feature_status_change(current_list, target_list):
            return [current >= target for current, target in zip(current_list, target_list)]

        print('order:', self.terra_obj.components_ordered_info)
        features = json.load(open(self.terra_obj.project.geojson_path))['features']
        cleaned_json = {"type": "FeatureCollection", "features": []}
        payload = {}
        for feat in features:
            end_the_loop = True
            feature_status_changed = False
            feature_uid = feat["properties"]["uid"]
            feature_type = feat["properties"]["class_name"]
            payload[feature_uid] = {"attachments": [], "category": None, "new_feature_type": None, "notes": "",
                                    "old_feature_type": feature_type,
                                    "progress": {}, "status_changed": False, "timestamp": None}

            # update components count based user order, if any succeeding component count match with its target count
            # then all the preceeding component considered as construction compeleted and there component count updated with respect to match there target count
            if self.terra_obj.components_ordered_info:
                succeeding_status = False
                for ordered_comp in self.terra_obj.components_ordered_info[::-1]:
                    comp_name, target_value = ordered_comp[0], ordered_comp[1].get("target_value", None)
                    if succeeding_status:
                        feat["properties"]["extraProperties"]["component"][comp_name]['count'] = \
                        feat["properties"]["extraProperties"][target_value]
                        print(comp_name, target_value)
                    else:
                        if int(feat["properties"]["extraProperties"]["component"][comp_name]['count']) == int(
                                feat["properties"]["extraProperties"][target_value]):
                            print(comp_name, target_value)
                            succeeding_status = True

            while end_the_loop:
                feature_id = feat["properties"]["class_name"]
                if self.workflow_detail_info.get(feature_id, None):
                    associated_workflow = self.workflow_detail_info[feature_id]
                    feature_condition = associated_workflow['required']
                    component_current_values = []
                    component_target_values = []
                    for workflow in associated_workflow["fields"]:
                        component_name = workflow["component_name"]
                        completion_value = feature_condition[workflow["uid"]]
                        component_new_count = int(feat["properties"]["extraProperties"]["component"][component_name]['count'])
                        component_target = int(feat["properties"]["workflowProgress"][workflow["uid"]]["total"])
                        current_component_count = int(feat["properties"]["workflowProgress"][workflow["uid"]]["current"])
                        if not feature_status_changed:
                            value = abs(component_new_count - current_component_count)
                        else:
                            if payload[feature_uid]["progress"].get(workflow["uid"], {}).get("value", None):
                                value = payload[feature_uid]["progress"][workflow["uid"]].get("value", 0)
                            else:
                                value = abs(component_new_count - current_component_count)

                        feat["properties"]["workflowProgress"][workflow["uid"]]["current"] = component_new_count
                        payload[feature_uid]['progress'][workflow["uid"]] = {"current": component_new_count,
                                                                             "value": value}
                        component_current_values.append(component_new_count / component_target)
                        component_target_values.append(completion_value)

                        # REMOVE print(feat["properties"]["class"], "-->",associated_workflow["destination_feat_name"], workflow["uid"], completion_value, component_name, component_new_count,component_target)

                    #Validating the current feautre workflow associated component counts with there total counts
                    #If validated then feature type changed to succeeding feature type 
                    status = check_feature_status_change(component_current_values, component_target_values)
                    print(status, feat['properties']["class"])
                    if status and all(status):
                        payload[feature_uid]["new_feature_type"] = associated_workflow.get("destination", None)
                        payload[feature_uid]["status_changed"] = True
                        feat["properties"]["class_name"] = associated_workflow.get("destination", None)
                        feat["properties"]["class"] = associated_workflow.get("destination_feat_name", None)
                        feat["properties"]["class_id"] = associated_workflow.get("destination_feat_class_id", None)
                        feature_status_changed = True
                    else:
                        end_the_loop = False

                    # pprint.pprint(payload)
                    # pprint.pprint(feat["properties"]["extraProperties"]["component_info"])

                else:
                    end_the_loop = False

            cleaned_json['features'].append(feat)

        # pprint.pprint(payload)

        url = f"https://terra-server.sensehawk.com/features/workflow-progress/?organization={self.terra_obj.project_details['organization']['uid']}"
        headers = {"Authorization": f"Token {self.terra_obj.core_token}"}
        response = requests.post(url, headers=headers, json=payload)
        print(response.status_code)
        print(response.json())

        self.terra_obj.project.vlayer.commitChanges()
        self.terra_obj.project.vlayer.startEditing()
        # disconnect any single added to existing vlayer
        self.terra_obj.project.vlayer.selectionChanged.disconnect()
        # remove existing json
        QgsProject.instance().removeMapLayers([self.terra_obj.project.vlayer.id()])
        with open(self.terra_obj.project.geojson_path, "w") as fi:
            json.dump(cleaned_json, fi)

        self.terra_obj.project.layer_edit_status = True
        # Add and Initializing Vlayer features
        self.terra_obj.project.initialize_vlayer()

    def close_dialogbox(self):
        self.reject()
