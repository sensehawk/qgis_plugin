# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Therm Tools
#                                  A QGIS plugin
#  This window has access to Tools for Therm application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """
import os
import cv2
import uuid 

from qgis.PyQt.QtCore import Qt , QPoint , QRectF 
from qgis.PyQt import QtWidgets, uic
import qgis
from qgis.core import QgsMessageLog, Qgis, QgsApplication, QgsTask, QgsFeatureRequest, QgsPoint, QgsPalLayerSettings, QgsVectorLayerSimpleLabeling, QgsTextFormat
from qgis.core import QgsField
from PyQt5.QtCore import QVariant

from PyQt5.QtWidgets import QPushButton,QLabel, QLineEdit
from PyQt5.QtGui import QKeySequence , QFont , QPainter , QPolygon , QImage
from PyQt5 import QtCore, QtGui, QtWidgets 
from datetime import datetime
from PIL import Image
from qgis.utils import iface
from exiftool import ExifTool
import numpy as np
import subprocess
from ..utils import sort_images
import json


class PhotoViewer(QtWidgets.QGraphicsView):
    photoClicked = QtCore.pyqtSignal(QtCore.QPoint)

    def __init__(self, thermlite_qc_window):
        super(PhotoViewer, self).__init__()
        self._zoom = 0
        self._empty = True
        self._scene = QtWidgets.QGraphicsScene(self)
        self._photo = QtWidgets.QGraphicsPixmapItem()
        self._scene.addItem(self._photo)
        self.setScene(self._scene)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(30, 30, 30)))
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.thermlite_qc_window = thermlite_qc_window


    def hasPhoto(self): 
        return not self._empty

    def fitInView(self, scale=True):
        rect = QtCore.QRectF(self._photo.pixmap().rect())
        if not rect.isNull():
            self.setSceneRect(rect)
            if self.hasPhoto():
                unity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))
                self.scale(1 / unity.width(), 1 / unity.height())
                viewrect = self.viewport().rect()
                scenerect = self.transform().mapRect(rect)
                factor = min(viewrect.width() / scenerect.width(),
                             viewrect.height() / scenerect.height())
                self.scale(factor, factor)
            self._zoom = 0

    def setPhoto(self, pixmap=None):
        self._zoom = 0
        if self.thermlite_qc_window.pan_toggle.isChecked():
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

        if pixmap and not pixmap.isNull():
            self._empty = False
            self._photo.setPixmap(pixmap)
        else:
            self._empty = True
            self._photo.setPixmap(QtGui.QPixmap())
        self.fitInView()

    def wheelEvent(self, event):
        if self.hasPhoto():
            if event.angleDelta().y() > 0:
                factor = 1.25
                self._zoom += 1
            else:
                factor = 0.8
                self._zoom -= 1
            if self._zoom > 0:
                self.scale(factor, factor)
            elif self._zoom == 0:
                self.fitInView()
            else:
                self._zoom = 0

    def toggleDragMode(self, switch):
        if switch:
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

    def mousePressEvent(self, event):
        if self._photo.isUnderMouse():
            self.photoClicked.emit(self.mapToScene(event.pos()).toPoint())
        super(PhotoViewer, self).mousePressEvent(event)

THERMLITE_QC_UI, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'thermliteQc.ui'))

class ThermliteQcWindow(QtWidgets.QDockWidget, THERMLITE_QC_UI):

    def __init__(self, project):
        """Constructor."""
        super(ThermliteQcWindow, self).__init__()
        self.setupUi(self)
        self.project = project
        self.geojson_path = project.geojson_path
        self.iface = iface
        self.active_layer = self.project.vlayer
        self.canvas = self.iface.mapCanvas()
        self.viewer = PhotoViewer(self)
        self.viewer.photoClicked.connect(self.photoClicked)
        self.image_layout.addWidget(self.viewer)
        self.image_tagged_info = {}
        self.issue_list = [[]]
        self.temp_issueUid = 100
        self.markerlocatoin = [0,0]
        #select folder path
        self.folder_path.clicked.connect(self.folderpath)
        # # Navigation buttons
        self.nxt_img.setShortcut('d')
        self.nxt_img.clicked.connect(self.load_nxtimg)
        self.previous_img.setShortcut('a')
        self.previous_img.clicked.connect(self.load_previous)
        # Temperature widgets
        self.temp_patch_x.setText('30')
        self.temp_patch_y.setText('30')
        self.max_percentile.setText('95')
        self.min_percentile.setText('10')
        self.temperature_toggle.stateChanged.connect(lambda x: self.toggle_temperature_fields(x))
        #marker and tag button
        self.pan_toggle.stateChanged.connect(lambda x: self.pixInfo(x))
        self.tag_button.clicked.connect(self.tag_image)
        self.image_index = 0
        self.iface.addDockWidget(Qt.RightDockWidgetArea, self)
        self.setFixedSize(628, 798)
        self.et = ExifTool()
        self.et.start()
        self.DJI_SDK_PATH = os.path.join(os.path.dirname(__file__), "dji_thermal_sdk")
        self.geojson = json.load(open(self.geojson_path))

    def toggle_temperature_fields(self, switch):
        self.temp_patch_x.setEnabled(switch)
        self.temp_patch_y.setEnabled(switch)
        self.max_percentile.setEnabled(switch)
        self.min_percentile.setEnabled(switch)
        self.delta_temp.setEnabled(switch)

    def get_temperature_map(self, image_path):
        metadata = self.et.get_metadata(image_path)
        camera = metadata["EXIF:Model"]
        if "MAVIC2-ENTERPRISE-ADVANCED" in camera or "H20T" in camera or "M3T" in camera:
            env = os.environ.copy()
            env['LD_LIBRARY_PATH'] = self.DJI_SDK_PATH
            subprocess.call(f"{os.path.join(self.DJI_SDK_PATH, 'dji_irp')} -s '{image_path}' -a measure -o temp.raw",
                            shell=True, env=env)
            degree_map = np.empty((512, 640), np.int16)
            degree_map.data = open("temp.raw", "rb").read()
            degree_map = degree_map / 10
        else:
            os.system('exiftool -RawThermalImage -b "{}" > raw.dat'.format(image_path))
            img = cv2.imread("raw.dat", cv2.IMREAD_UNCHANGED)
            os.remove('raw.dat')

            r1 = metadata['APP1:PlanckR1']
            r2 = metadata['APP1:PlanckR2']
            o = metadata['APP1:PlanckO']
            b = metadata['APP1:PlanckB']
            f = metadata['APP1:PlanckF']

            emissivity = metadata['APP1:Emissivity']
            if not emissivity:
                emissivity = 0.86
            refl_temp = metadata['APP1:ReflectedApparentTemperature']
            raw_refl = r1 / (r2 * (np.exp(b / (refl_temp + 273.15)) - f)) - o
            raw_obj = (img - (1 - emissivity) * raw_refl) / emissivity
            degree_map = b / np.log(r1 / (r2 * (raw_obj + o)) + f) - 273.15
        return degree_map

    def extract_temperature(self, pos, image_w=640, image_h=512):
        x, y = int(pos.x()), int(pos.y())
        temp_patch_x = int(self.temp_patch_x.text())
        temp_patch_y = int(self.temp_patch_y.text())
        min_x = max(0, int(x-temp_patch_x/2))
        max_x = min(image_w, int(x+temp_patch_x/2))
        min_y = max(0, int(y-temp_patch_y/2))
        max_y = min(image_h, int(y+temp_patch_y/2))
        temp_patch = self.temperature_map[min_y:max_y, min_x:max_x]
        max_temp = np.percentile(temp_patch, int(self.max_percentile.text()))
        min_temp = np.percentile(temp_patch, int(self.min_percentile.text()))
        self.delta_temp.setText("{:.2f}".format(max_temp-min_temp))

    def folderpath(self):
        required_fields = {'timestamp':QVariant.String,'temperature_difference':QVariant.Double,  'num_images_tagged':QVariant.Double,
                            'temperature_min':QVariant.Double,'temperature_max':QVariant.Double, 'temp_uid':QVariant.Double}
        
        self.fields_validator(required_fields, self.active_layer)

        self.images_dir = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select the images folder')
        self.sorted_images, self.sorted_timestamps = sort_images(self.images_dir)
        # Enable num_images_tagged label
        self.num_images_label = QgsPalLayerSettings()
        self.num_images_label.fieldName = 'num_images_tagged'
        self.num_images_label.enabled = True
        self.num_images_label.setFormat(QgsTextFormat())
        self.num_images_label.placement = QgsPalLayerSettings.Line
        labeler = QgsVectorLayerSimpleLabeling(self.num_images_label)
        self.active_layer.setLabelsEnabled(True)
        self.active_layer.setLabeling(labeler)
        self.active_layer.triggerRepaint()

    def pixInfo(self, switch):
        self.viewer.toggleDragMode(switch)

    def load_image(self, image_index):
        self.timestamp.setText(str(self.sorted_timestamps[image_index]))
        self.image_path = self.sorted_images[self.image_index]
        self.current_loaded_img.setText(self.sorted_images[self.image_index])
        self.image = cv2.imread(self.image_path)
        self.height, self.width, self.channel = self.image.shape
        self.bytesPerLine = 3 * self.width
        qImg = QImage(self.image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
        self.current_image = QtGui.QPixmap(qImg)
        self.viewer.setPhoto(self.current_image)
        # Load temperature map if temperature is enabled
        if self.temperature_toggle.isChecked():
            self.temperature_map = self.get_temperature_map(self.image_path)
        else:
            self.temperature_map = None

    def load_nxtimg(self):
        self.image_index += 1
        self.load_image(self.image_index)

    def load_previous(self):
        self.image_index -=1
        self.load_image(self.image_index)

    def draw_box(self, imagecopy, x, y, w=32, h=32, image_w=640, image_h=512):
        x1 = max(int(x-w/2), 0)
        y1 = max(int(y-h/2), 0)
        x2 = min(int(x+w/2), image_w)
        y2 = min(int(y+h/2), image_h)
        image = cv2.rectangle(imagecopy, (x1, y1), (x2, y2), [0, 0, 255], 2, 1)
        image = cv2.drawMarker(imagecopy, (x, y), [0, 255, 0], cv2.MARKER_CROSS, 2, 2)
        return image
    
    def photoClicked(self, pos):
        if self.viewer.dragMode()  == QtWidgets.QGraphicsView.NoDrag:
            print(pos.x(), pos.y())
            self.marker_info.setText('%d, %d' % (pos.x(), pos.y()))
            self.markerlocatoin = [pos.x(),pos.y()]
            x = pos.x()
            y = pos.y() 
            w = int(self.temp_patch_x.text())
            h = int(self.temp_patch_y.text())
            self.painted_image = self.draw_box(self.image.copy(), x, y, w, h)
            qImg = QImage(self.painted_image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
            self.current_image = QtGui.QPixmap(qImg)
            self.viewer.setPhoto(self.current_image)
            if self.temperature_toggle.isChecked():
                self.extract_temperature(pos)

    def fields_validator(self, required_fields, layer):
        fname = list(required_fields.keys())
        for field in fname:
            variant = required_fields[field]
            if layer.fields().indexFromName(field) == -1:
                fieldz = QgsField(field , variant)
                layer.dataProvider().addAttributes([fieldz])
                layer.updateFields() # update layer fields after creating new one
        layer.commitChanges()
        layer.startEditing()
        
    def tag_image(self):
        
        self.active_layer.commitChanges()
        self.active_layer.startEditing()

        # Check if there are any selected features
        if self.active_layer.selectedFeatures():
            sfeature = self.active_layer.selectedFeatures()[-1]
        else:
            *_, sfeature = self.active_layer.getFeatures()

        self.active_layer.removeSelection()

        sx = sfeature.geometry().centroid().asPoint().x()
        sy = sfeature.geometry().centroid().asPoint().y()
        
        print(sx,sy ,'and' , self.issue_list[-1])

        if sfeature['temp_uid'] is None or [sx, sy] != self.issue_list[-1]:
            print('adding in new issue')
            self.temp_issueUid += 1
            sfeature['temp_uid'] = self.temp_issueUid
            sfeature['timestamp'] = str(self.sorted_timestamps[self.image_index])
            self.image_tagged_info[self.temp_issueUid] = [{self.sorted_images[self.image_index][0]:self.markerlocatoin}]
            self.issue_list.append([sx, sy])
        else:
            print('adding in existing isuues')
            self.image_tagged_info[self.temp_issueUid].append({self.sorted_images[self.image_index][0]:self.markerlocatoin})
        print(self.image_tagged_info)
        sfeature['num_images_tagged'] = len(self.image_tagged_info[self.temp_issueUid])
        self.active_layer.updateFeature(sfeature)

        