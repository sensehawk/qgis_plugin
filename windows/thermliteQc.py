# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Therm Tools
#                                  A QGIS plugin
#  This window has access to Tools for Therm application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """
import os
import cv2
import glob
from datetime import datetime
from pathlib import Path

from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsVectorLayer, QgsApplication, QgsTask, QgsPalLayerSettings, QgsVectorLayerSimpleLabeling, QgsTextFormat, Qgis, QgsField, QgsTextBufferSettings
from PyQt5.QtCore import QVariant, QPoint 

from PyQt5.QtGui import QImage, QColor, QFont
from PyQt5 import QtCore, QtGui, QtWidgets 
from qgis.utils import iface
from .packages.exiftool import ExifToolHelper
import numpy as np
import subprocess
from ..utils import sort_images, upload, combobox_modifier, categorize_layer, get_presigned_post_urls, fields_validator, create_custom_label
import json
from ..constants import S3_BUCKET, S3_REGION

exiftool_path = r'{}'.format(os.path.realpath(os.path.join(os.path.dirname(__file__), "exiftool.exe")))

class PhotoViewer(QtWidgets.QGraphicsView):
    photoClicked = QtCore.pyqtSignal(QtCore.QPoint)

    def __init__(self, thermlite_qc_window):
        super(PhotoViewer, self).__init__()
        self._zoom = 0
        self._empty = True
        self._scene = QtWidgets.QGraphicsScene(self)
        self._photo = QtWidgets.QGraphicsPixmapItem()
        self._scene.addItem(self._photo)
        self.setScene(self._scene)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(30, 30, 30)))
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.thermlite_qc_window = thermlite_qc_window


    def hasPhoto(self): 
        return not self._empty

    def fitInView(self, scale=True):
        rect = QtCore.QRectF(self._photo.pixmap().rect())
        if not rect.isNull():
            self.setSceneRect(rect)
            if self.hasPhoto():
                unity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))
                self.scale(1 / unity.width(), 1 / unity.height())
                viewrect = self.viewport().rect()
                scenerect = self.transform().mapRect(rect)
                factor = min(viewrect.width() / scenerect.width(),
                             viewrect.height() / scenerect.height())
                self.scale(factor, factor)
            self._zoom = 0

    def setPhoto(self, pixmap=None):
        self._zoom = 0
        if self.thermlite_qc_window.pan_toggle.isChecked():
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

        if pixmap and not pixmap.isNull():
            self._empty = False
            self._photo.setPixmap(pixmap)
        else:
            self._empty = True
            self._photo.setPixmap(QtGui.QPixmap())
        self.fitInView()

    def wheelEvent(self, event):
        if self.hasPhoto():
            if event.angleDelta().y() > 0:
                factor = 1.25
                self._zoom += 1
            else:
                factor = 0.8
                self._zoom -= 1
            if self._zoom > 0:
                self.scale(factor, factor)
            elif self._zoom == 0:
                self.fitInView()
            else:
                self._zoom = 0

    def toggleDragMode(self, switch):
        if switch:
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

    def mousePressEvent(self, event):
        if self._photo.isUnderMouse():
            self.photoClicked.emit(self.mapToScene(event.pos()).toPoint())
        super(PhotoViewer, self).mousePressEvent(event)

THERMLITE_QC_UI, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'thermliteQc.ui'))

class ThermliteQcWindow(QtWidgets.QWidget, THERMLITE_QC_UI):

    def __init__(self, therm_tools, project):
        """Constructor."""
        super(ThermliteQcWindow, self).__init__()
        self.setupUi(self)
        self.canvas_logger = therm_tools.canvas_logger
        self.logger = therm_tools.logger
        self.logger(exiftool_path)
        self.therm_tools = therm_tools
        self.project = project
        self.project.manual_tagging_widget = self
        self.geojson_path = project.geojson_path
        self.projectUid = project.project_details['uid']
        self.iface = iface
        self.canvas = self.iface.mapCanvas()
        self.viewer = PhotoViewer(self)
        self.viewer.photoClicked.connect(self.photoClicked)
        self.image_layout.addWidget(self.viewer)
        self.image_tagged_info = {}
        self.x, self.y = 0, 0 
        #select folder path
        self.folder_path.clicked.connect(self.folderpath)
        # # Navigation buttons
        self.nxt_img.clicked.connect(self.load_nxtimg)
        self.previous_img.clicked.connect(self.load_previous)
        # Initially keep the buttons disabled
        for b in [self.nxt_img, self.previous_img]:
            b.setEnabled(False)
        # Temperature widgets
        self.temp_patch_x.setText('30')
        self.temp_patch_y.setText('30')
        self.max_percentile.setText('95')
        self.min_percentile.setText('10')
        self.temp_patch_x.textChanged.connect(self.photoClicked)
        self.temp_patch_y.textChanged.connect(self.photoClicked)
        self.max_percentile.textChanged.connect(self.photoClicked)
        self.min_percentile.textChanged.connect(self.photoClicked)
        self.temperature_toggle.stateChanged.connect(lambda x: self.toggle_temperature_fields(x))
        #marker and tag button
        self.pan_toggle.stateChanged.connect(lambda x: self.pixInfo(x))
        self.tag_button.clicked.connect(self.tag_image)
        self.tag_button.setShortcut("Space")
        self.image_index = 0
        self.setFixedSize(628, 798)
        self.et = ExifToolHelper()
        self.DJI_SDK_PATH = os.path.realpath(os.path.join(os.path.dirname(__file__), "dji_thermal_sdk"))
        self.geojson = json.load(open(self.geojson_path))
        self.project.project_tabs_widget.currentChanged.connect(self.hide_widget)
        self.required_fields = {'num_images_tagged':QVariant.Double, 
                                'timestamp':QVariant.String}
        #save tagged data
        self.save_tagged_data.clicked.connect(self.parse_tagged_data)
        self.nearest_image_button.clicked.connect(self.show_nearest_image)

    def show_nearest_image(self):
        if self.project.vlayer.selectedFeatures():
            sfeature = self.project.vlayer.selectedFeatures()[-1]
        else:
            self.canvas_logger('No feature is selected...')
            return None
        sfeature_x, sfeature_y = sfeature.geometry().centroid().asPoint().x(), sfeature.geometry().centroid().asPoint().y()
        distance = np.linalg.norm(self.long_lat-[sfeature_x, sfeature_y], axis=1)
        min_index = np.argsort(distance)[:5]
        self.image_selector.setCurrentIndex(min_index[0])


    def pixInfo(self, switch):
        self.viewer.toggleDragMode(switch)
        
    def hide_widget(self):
        self.project.docktool_widget.hide()
        self.therm_tools.uncheck_all_buttons()

    def toggle_temperature_fields(self, switch):
        self.temp_patch_x.setEnabled(switch)
        self.temp_patch_y.setEnabled(switch)
        self.max_percentile.setEnabled(switch)
        self.min_percentile.setEnabled(switch)
        self.delta_temp.setEnabled(switch)

    def get_temperature_map(self, image_path):
        metadata = self.et.get_metadata(image_path)[0]
        camera = metadata["EXIF:Model"]
        if "MAVIC2-ENTERPRISE-ADVANCED" in camera or "H20T" in camera or "M3T" in camera or "M30T" in camera:
            download_path = str(Path.home() / "Downloads")
            temp_raw_path = os.path.join(download_path+'\\'+'temp.raw')
            subprocess.run(f"{os.path.join(self.DJI_SDK_PATH, 'dji_irp.exe')} -s {image_path} -a measure -o {temp_raw_path}", shell=True)
            degree_map = np.empty((512, 640), np.int16)
            degree_map.data = open(temp_raw_path, "rb").read()
            os.remove(temp_raw_path)
            degree_map = degree_map / 10
        else:
            os.system('{} -RawThermalImage -b "{}" > raw.dat'.format(exiftool_path, image_path))
            img = cv2.imread(os.path.join(os.getcwd(), "raw.dat"), cv2.IMREAD_UNCHANGED)
            os.remove(os.path.join(os.getcwd(), "raw.dat"))

            r1 = metadata['APP1:PlanckR1']
            r2 = metadata['APP1:PlanckR2']
            o = metadata['APP1:PlanckO']
            b = metadata['APP1:PlanckB']
            f = metadata['APP1:PlanckF']

            emissivity = metadata['APP1:Emissivity']
            if not emissivity:
                emissivity = 0.86
            refl_temp = metadata['APP1:ReflectedApparentTemperature']
            raw_refl = r1 / (r2 * (np.exp(b / (refl_temp + 273.15)) - f)) - o
            raw_obj = (img - (1 - emissivity) * raw_refl) / emissivity
            degree_map = b / np.log(r1 / (r2 * (raw_obj + o)) + f) - 273.15
        return degree_map

    def extract_temperature(self, image_w=640, image_h=512):
        x, y = self.x , self.y
        temp_patch_x = int(self.temp_patch_x.text().strip() or 1)
        temp_patch_y = int(self.temp_patch_y.text().strip() or 1)
        if temp_patch_x and temp_patch_y:
            min_x = max(0, int(x-temp_patch_x/2))
            max_x = min(image_w, int(x+temp_patch_x/2))
            min_y = max(0, int(y-temp_patch_y/2))
            max_y = min(image_h, int(y+temp_patch_y/2))
            temp_patch = self.temperature_map[min_y:max_y, min_x:max_x]
            try:
                self.max_temp = np.percentile(temp_patch, int(self.max_percentile.text().strip() or 1))
                self.min_temp = np.percentile(temp_patch, int(self.min_percentile.text().strip() or 1))
                self.delta_temp.setText("{:.2f}".format(float(self.max_temp-self.min_temp)))
            except Exception as e:
                self.canvas_logger(str(e), level=Qgis.Warning)
                return None
    
    def sort_task_callback(self, sort_task_status, image_sort_task):
        if sort_task_status != 3:
            return None
        result = image_sort_task.returned_values
        self.sorted_images, self.sorted_timestamps, self.long_lat = result['sorted_images'], result['sorted_timestamps'], result['sorted_long_lat']
        if not self.sorted_images:
            self.canvas_logger("No valid images in selected folder", level=Qgis.Warning)
            return None
        # Enable the buttons
        for b in [self.nxt_img, self.previous_img]:
            b.setEnabled(True)
        raw_images = [image.split("\\")[-1] for image in self.sorted_images]
        self.image_selector = combobox_modifier(self.current_loaded_img, raw_images)
        self.image_selector.currentIndexChanged.connect(self.change_image)
        # self.trigger_custom_label(self.project.vlayer)
        self.load_image(0)
    
    
    def folderpath(self):
        self.images_dir = os.path.realpath(QtWidgets.QFileDialog.getExistingDirectory(self, 'Select the images folder'))
        self.logger(f"Images dir selected: {self.images_dir}")
        if not self.images_dir:
            return None
        self.canvas_logger('Sorting images')
        image_sort_task = QgsTask.fromFunction("Sort Images", sort_images, self.images_dir, self.logger)
        QgsApplication.taskManager().addTask(image_sort_task)
        image_sort_task.statusChanged.connect(lambda sort_task_status: self.sort_task_callback(sort_task_status, image_sort_task))

    def change_image(self):
        print(f"Current image index: {self.image_selector.currentIndex()}")
        print(f"Changed image index: {self.sorted_images[self.image_index]}")
        print(f"Current image coords: {self.long_lat[self.image_index]}")
        self.image_index = self.image_selector.currentIndex()
        self.load_image(self.image_index)
        self.marker_info.setText('')

    def load_image(self, image_index):
        self.timestamp.setText(str(self.sorted_timestamps[image_index]))
        self.image_path = self.sorted_images[self.image_index]
        self.image = cv2.imread(self.image_path)
        self.height, self.width, self.channel = self.image.shape
        self.bytesPerLine = 3 * self.width
        qImg = QImage(self.image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
        self.current_image = QtGui.QPixmap(qImg)
        self.viewer.setPhoto(self.current_image)
        # Load temperature map if temperature is enabled
        if self.temperature_toggle.isChecked():
            self.temperature_map = self.get_temperature_map(r'{}'.format(self.image_path))
        else:
            self.temperature_map = None

    def load_nxtimg(self):
        self.image_index += 1
        if self.image_index < 0:
            self.image_index = len(self.sorted_images)-1
        elif self.image_index > len(self.sorted_images)-1:
            self.image_index = 0

        self.image_selector.setCurrentIndex(self.image_index)


    def load_previous(self):
        self.image_index -=1
        if self.image_index < 0:
            self.image_index = len(self.sorted_images)-1
        elif self.image_index > len(self.sorted_images)-1:
            self.image_index = 0

        self.image_selector.setCurrentIndex(self.image_index)


    def draw_box(self, imagecopy, x, y, w=32, h=32, image_w=640, image_h=512):
        x1 = max(int(x-w/2), 0)
        y1 = max(int(y-h/2), 0)
        x2 = min(int(x+w/2), image_w)
        y2 = min(int(y+h/2), image_h)
        image = cv2.rectangle(imagecopy, (x1, y1), (x2, y2), [0, 0, 255], 2, 1)
        image = cv2.drawMarker(imagecopy, (x, y), [0, 255, 0], cv2.MARKER_CROSS, 2, 2)
        return image
    
    def photoClicked(self, pos=None):
        if self.viewer.dragMode()  == QtWidgets.QGraphicsView.NoDrag:
            if isinstance(pos, QPoint):
                self.marker_info.setText('%d, %d' % (pos.x(), pos.y()))
                self.markerlocation = [pos.x(),pos.y()]
                self.x = pos.x()
                self.y = pos.y() 
            else:
                self.marker_info.setText('%d, %d' % (self.x, self.y))
                self.markerlocation = [self.x, self.y]
            
            w = int(self.temp_patch_x.text().strip() or 1)
            h = int(self.temp_patch_y.text().strip() or 1)
            if w and h:
                self.painted_image = self.draw_box(self.image.copy(), self.x, self.y, w, h)
                qImg = QImage(self.painted_image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
                self.current_image = QtGui.QPixmap(qImg)
                self.viewer.setPhoto(self.current_image)
                if self.temperature_toggle.isChecked():
                    self.extract_temperature()
        
    def tag_image(self):
        self.project.vlayer.startEditing()
        # Check if there are any selected features
        if self.project.vlayer.selectedFeatures():
            sfeature = self.project.vlayer.selectedFeatures()[-1]
        else:
            self.project.vlayer.commitChanges()
            self.project.vlayer.startEditing()
            *_, sfeature = self.project.vlayer.getFeatures()
        self.project.vlayer.removeSelection()

        if self.temperature_toggle.isChecked():
            if not self.delta_temp.text():
                self.canvas_logger("Invalid image for temperature", level=Qgis.Warning)
                return None

        # Get selected feature details
        uid = sfeature['uid']
        sfeature_image_tagged_info = self.image_tagged_info.get(uid, {})
        image_path = self.sorted_images[self.image_index]
        
        # Tag temperature info if temperature is enabled
        if self.temperature_toggle.isChecked():
            dt = unicode(self.sorted_timestamps[self.image_index].replace(microsecond=0))
            sfeature['timestamp'] = dt
            sfeature['temperature_difference'] = float(format(self.max_temp-self.min_temp, ".2f"))
            sfeature['temperature_min']  = float(self.min_temp)
            sfeature['temperature_max'] = float(self.max_temp)
            print(sfeature['temperature_difference'])
        # Update num images tagged if the image does not already exist in the feature tagged info
        if image_path not in sfeature_image_tagged_info:
            try:
                num_images_tagged = sfeature['num_images_tagged']
            except KeyError:
                fields_validator(self.required_fields, self.project.vlayer)
                num_images_tagged = sfeature['num_images_tagged']
            # Make num_images_tagged to zero if issue is copy pasted or freshly created   
            if not sfeature_image_tagged_info and not self.therm_tools.num_tagged_rawimages.get(uid, None):
                sfeature['num_images_tagged'] = 0
            if not num_images_tagged:
                sfeature['num_images_tagged'] = 1
                self.therm_tools.num_tagged_rawimages[uid] = 1
            else:
                sfeature['num_images_tagged'] = int(sfeature['num_images_tagged']) + 1
                self.therm_tools.num_tagged_rawimages[uid] = int(sfeature['num_images_tagged']) + 1
            
        # If the same marker location and the same image exists, don't add it again
        if sfeature_image_tagged_info.get(image_path, [0, 0]) != self.markerlocation:        
            sfeature_image_tagged_info[image_path] = self.markerlocation
            print(f"Tagged image info: {self.image_tagged_info}")
        else:
            return None
        # Save sfeature tagged info for later use
        self.image_tagged_info[uid] = sfeature_image_tagged_info
        self.project.vlayer.updateFeature(sfeature)
        # Set the marker location to default [0, 0]
        self.markerlocation = [0, 0]

    def parse_tagged_data(self):
        self.canvas_logger('Saving changes to Sensehawk Core')
        self.project.vlayer.commitChanges()
        self.upload_image_list = []
        aws_tagged_images = {}
        for uid in self.image_tagged_info:
            imgs_info = self.image_tagged_info[uid]
            raw_image = []
            image_num = 0
            for next_image in imgs_info:
                if next_image not in self.upload_image_list:
                    self.upload_image_list.append(next_image)
                image = next_image.split('\\')[-1]
                markerlocation = imgs_info[next_image]
                image_type = 'Thermal Raw Image'
                aws_image = {"location": markerlocation,
                    "service": {'bucket': S3_BUCKET,
                                'key': f'hawkai/{self.projectUid}/IR_rawimage/{image}',
                                'name': 'aws_s3',
                                'stage': 'qgis_plugin',
                                'region': S3_REGION,
                                'filename': f'{image_type} {image_num}.jpg'}}
                image_num += 1 
                raw_image.append(aws_image)

            aws_tagged_images[uid] = raw_image
    
        with open(self.project.geojson_path, 'r') as f:
            file = json.load(f)

        # Saving tagged Geojson for backup
        with open(self.images_dir+f'\\{self.projectUid}_tagged.json', 'w') as p:
            json.dump(file , p)

        # Saving tagged images meta data for backup
        with open(self.images_dir+f'\\{self.projectUid}_image_metadata.json', 'w') as g:
            json.dump(aws_tagged_images, g)

        geojson = {'type':'FeatureCollection','features':[]}
        features = file['features']
        for feature in features:
            mapping_uid  = feature['properties'].get('uid', None)
            if not mapping_uid:
                geojson['features'].append(feature)
                continue
            raw_images = feature['properties']['raw_images']
            if isinstance(raw_images, type('')) or len(raw_images) == 0:
                feature['properties']['raw_images'] = aws_tagged_images.get(mapping_uid, [])
            else:
                feature['properties']['raw_images'] += aws_tagged_images.get(mapping_uid, [])
            if 'num_images_tagged' in feature['properties']:
                feature['properties'].pop('num_images_tagged')
            geojson['features'].append(feature)

        #remove exiting vlayer and add tagged vlayer
        self.project.qgis_project.removeMapLayers([self.project.vlayer.id()])
        
        with open(self.project.geojson_path, 'w') as f:
            json.dump(geojson, f)
        
        # Add updated vlayer and Initialize features
        self.project.initialize_vlayer()
        #Upload tagged images to S3 Bucket
        self.initiate_upload_process()
        

    def upload_callback(self, upload_task_status, upload_task):
        if upload_task_status != 3:
            return None
        result = upload_task.returned_values
        print(f"{result['num_images']} uploaded")
        self.project.project_tabs_window.save_project()
        #clear image_tagged info to avoid re-tagging already tagged ones
        self.image_tagged_info.clear()
        self.project.vlayer.startEditing()
        self.canvas_logger("Project geojson saved in SenseHawk App", level=Qgis.Success)
        # Reload service object urls if viewer exists
        # if self.therm_tools.therm_viewer_widget:
        #     self.therm_tools.therm_viewer_widget.generate_service_objects()

    def upload_task(self, get_urls_task_status, get_urls_task):
        if get_urls_task_status != 3:
            return None
        post_urls_data = get_urls_task.returned_values["response"]
        upload_task_inputs = {'imageslist':self.upload_image_list,
                              'projectUid':self.projectUid,
                              'img_dir': self.images_dir,
                              'post_urls_data': post_urls_data}
        upload_task = QgsTask.fromFunction("Upload", upload, upload_task_inputs)
        QgsApplication.taskManager().addTask(upload_task)
        upload_task.statusChanged.connect(lambda upload_task_status: self.upload_callback(upload_task_status, upload_task))

    def initiate_upload_process(self):
        task_inputs = {'imageslist':self.upload_image_list,
                       'projectUid':self.projectUid,
                       'core_token': self.project.core_token,
                       'orgUid': self.project.project_details["organization"]["uid"]}
        get_urls_task = QgsTask.fromFunction("Get post URLs", get_presigned_post_urls, task_inputs)
        QgsApplication.taskManager().addTask(get_urls_task)
        get_urls_task.statusChanged.connect(lambda task_status: self.upload_task(task_status, get_urls_task))

        

