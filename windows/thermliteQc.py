# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Therm Tools
#                                  A QGIS plugin
#  This window has access to Tools for Therm application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """
import os
import cv2
import glob
from datetime import datetime

from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsVectorLayer, QgsApplication, QgsTask, QgsPalLayerSettings, QgsVectorLayerSimpleLabeling, QgsTextFormat, Qgis, QgsField, QgsTextBufferSettings
from PyQt5.QtCore import QVariant

from PyQt5.QtGui import QImage, QColor, QFont
from PyQt5 import QtCore, QtGui, QtWidgets 
from qgis.utils import iface
from .packages.exiftool import ExifToolHelper
import numpy as np
import subprocess
from ..utils import sort_images, upload, combobox_modifier, categorize_layer, get_presigned_post_urls, fields_validator
import json
from ..constants import S3_BUCKET, S3_REGION

exiftool_path = r'{}'.format(os.path.realpath(os.path.join(os.path.dirname(__file__), "exiftool.exe")))

class PhotoViewer(QtWidgets.QGraphicsView):
    photoClicked = QtCore.pyqtSignal(QtCore.QPoint)

    def __init__(self, thermlite_qc_window):
        super(PhotoViewer, self).__init__()
        self._zoom = 0
        self._empty = True
        self._scene = QtWidgets.QGraphicsScene(self)
        self._photo = QtWidgets.QGraphicsPixmapItem()
        self._scene.addItem(self._photo)
        self.setScene(self._scene)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(30, 30, 30)))
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.thermlite_qc_window = thermlite_qc_window


    def hasPhoto(self): 
        return not self._empty

    def fitInView(self, scale=True):
        rect = QtCore.QRectF(self._photo.pixmap().rect())
        if not rect.isNull():
            self.setSceneRect(rect)
            if self.hasPhoto():
                unity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))
                self.scale(1 / unity.width(), 1 / unity.height())
                viewrect = self.viewport().rect()
                scenerect = self.transform().mapRect(rect)
                factor = min(viewrect.width() / scenerect.width(),
                             viewrect.height() / scenerect.height())
                self.scale(factor, factor)
            self._zoom = 0

    def setPhoto(self, pixmap=None):
        self._zoom = 0
        if self.thermlite_qc_window.pan_toggle.isChecked():
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

        if pixmap and not pixmap.isNull():
            self._empty = False
            self._photo.setPixmap(pixmap)
        else:
            self._empty = True
            self._photo.setPixmap(QtGui.QPixmap())
        self.fitInView()

    def wheelEvent(self, event):
        if self.hasPhoto():
            if event.angleDelta().y() > 0:
                factor = 1.25
                self._zoom += 1
            else:
                factor = 0.8
                self._zoom -= 1
            if self._zoom > 0:
                self.scale(factor, factor)
            elif self._zoom == 0:
                self.fitInView()
            else:
                self._zoom = 0

    def toggleDragMode(self, switch):
        if switch:
            self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        else:
            self.setDragMode(QtWidgets.QGraphicsView.NoDrag)

    def mousePressEvent(self, event):
        if self._photo.isUnderMouse():
            self.photoClicked.emit(self.mapToScene(event.pos()).toPoint())
        super(PhotoViewer, self).mousePressEvent(event)

THERMLITE_QC_UI, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'thermliteQc.ui'))

class ThermliteQcWindow(QtWidgets.QWidget, THERMLITE_QC_UI):

    def __init__(self, therm_tools, project):
        """Constructor."""
        super(ThermliteQcWindow, self).__init__()
        self.setupUi(self)
        self.canvas_logger = therm_tools.canvas_logger
        self.logger = therm_tools.logger
        self.logger(exiftool_path)
        self.therm_tools = therm_tools
        self.project = project
        self.project.manual_tagging_widget = self
        self.geojson_path = project.geojson_path
        self.projectUid = project.project_details['uid']
        self.iface = iface
        self.canvas = self.iface.mapCanvas()
        self.viewer = PhotoViewer(self)
        self.viewer.photoClicked.connect(self.photoClicked)
        self.image_layout.addWidget(self.viewer)
        self.image_tagged_info = {}
        #select folder path
        self.folder_path.clicked.connect(self.folderpath)
        # # Navigation buttons
        self.nxt_img.setShortcut('d')
        self.nxt_img.clicked.connect(self.load_nxtimg)
        self.previous_img.setShortcut('a')
        self.previous_img.clicked.connect(self.load_previous)
        # Initially keep the buttons disabled
        for b in [self.nxt_img, self.previous_img]:
            b.setEnabled(False)
        # Temperature widgets
        self.temp_patch_x.setText('30')
        self.temp_patch_y.setText('30')
        self.max_percentile.setText('95')
        self.min_percentile.setText('10')
        self.temperature_toggle.stateChanged.connect(lambda x: self.toggle_temperature_fields(x))
        #marker and tag button
        self.pan_toggle.stateChanged.connect(lambda x: self.pixInfo(x))
        self.tag_button.clicked.connect(self.tag_image)
        self.tag_button.setShortcut("Space")
        self.image_index = 0
        self.setFixedSize(628, 798)
        self.et = ExifToolHelper()
        self.DJI_SDK_PATH = os.path.realpath(os.path.join(os.path.dirname(__file__), "dji_thermal_sdk"))
        self.geojson = json.load(open(self.geojson_path))
        self.project.project_tabs_widget.currentChanged.connect(self.hide_widget)

        #save tagged data
        self.save_tagged_data.clicked.connect(self.parse_tagged_data)
    
    def pixInfo(self, switch):
        self.viewer.toggleDragMode(switch)
        
    def hide_widget(self):
        self.project.docktool_widget.hide()
        self.therm_tools.uncheck_all_buttons()

    def toggle_temperature_fields(self, switch):
        self.temp_patch_x.setEnabled(switch)
        self.temp_patch_y.setEnabled(switch)
        self.max_percentile.setEnabled(switch)
        self.min_percentile.setEnabled(switch)
        self.delta_temp.setEnabled(switch)

    def get_temperature_map(self, image_path):
        metadata = self.et.get_metadata(image_path)[0]
        camera = metadata["EXIF:Model"]
        if "MAVIC2-ENTERPRISE-ADVANCED" in camera or "H20T" in camera or "M3T" in camera:
            os.system(f"{os.path.join(self.DJI_SDK_PATH, 'dji_irp.exe')} -s {image_path} -a measure -o temp.raw")
            degree_map = np.empty((512, 640), np.int16)
            degree_map.data = open(os.path.join(os.getcwd(), "temp.raw"), "rb").read()
            os.remove(os.path.join(os.getcwd(), "temp.raw"))
            degree_map = degree_map / 10
        else:
            os.system('{} -RawThermalImage -b "{}" > raw.dat'.format(exiftool_path, image_path))
            img = cv2.imread(os.path.join(os.getcwd(), "raw.dat"), cv2.IMREAD_UNCHANGED)
            os.remove(os.path.join(os.getcwd(), "raw.dat"))

            r1 = metadata['APP1:PlanckR1']
            r2 = metadata['APP1:PlanckR2']
            o = metadata['APP1:PlanckO']
            b = metadata['APP1:PlanckB']
            f = metadata['APP1:PlanckF']

            emissivity = metadata['APP1:Emissivity']
            if not emissivity:
                emissivity = 0.86
            refl_temp = metadata['APP1:ReflectedApparentTemperature']
            raw_refl = r1 / (r2 * (np.exp(b / (refl_temp + 273.15)) - f)) - o
            raw_obj = (img - (1 - emissivity) * raw_refl) / emissivity
            degree_map = b / np.log(r1 / (r2 * (raw_obj + o)) + f) - 273.15
        return degree_map

    def extract_temperature(self, pos, image_w=640, image_h=512):
        x, y = int(pos.x()), int(pos.y())
        temp_patch_x = int(self.temp_patch_x.text())
        temp_patch_y = int(self.temp_patch_y.text())
        min_x = max(0, int(x-temp_patch_x/2))
        max_x = min(image_w, int(x+temp_patch_x/2))
        min_y = max(0, int(y-temp_patch_y/2))
        max_y = min(image_h, int(y+temp_patch_y/2))
        temp_patch = self.temperature_map[min_y:max_y, min_x:max_x]
        self.max_temp = np.percentile(temp_patch, int(self.max_percentile.text()))
        self.min_temp = np.percentile(temp_patch, int(self.min_percentile.text()))
        self.delta_temp.setText("{:.2f}".format(self.max_temp-self.min_temp))
    
    def sort_task_callback(self, sort_task_status, image_sort_task):
        if sort_task_status != 3:
            return None
        result = image_sort_task.returned_values
        self.sorted_images, self.sorted_timestamps = result['sorted_images'], result['sorted_timestamps']
        if not self.sorted_images:
            self.canvas_logger("No valid images in selected folder", level=Qgis.Warning)
            return None
        # Enable the buttons
        for b in [self.nxt_img, self.previous_img]:
            b.setEnabled(True)
        raw_images = [image.split("\\")[-1] for image in self.sorted_images]
        self.image_selector = combobox_modifier(self.current_loaded_img, raw_images)
        self.image_selector.currentIndexChanged.connect(self.change_image)
        self.trigger_custom_label(self.project.vlayer)
        self.load_image(0)
    
    def generate_num_tagged_rawimages(self):
        # Get num tagged raw images that already exists in the geojson
        features = json.load(open(self.project.geojson_path))["features"]
        num_tagged_rawimages = {}
        for feature in features:
            num_tagged_rawimages[feature["properties"].get("uid", None)] = len(feature["properties"].get("raw_images", []))
        # Loop through layer features and add num_tagged_rawimages as a field for labeler
        features = self.project.vlayer.getFeatures()
        for feature in features:
            uid = feature["uid"]
            feature["num_images_tagged"] = num_tagged_rawimages.get(uid, 0)
            self.project.vlayer.updateFeature(feature)
            
    def trigger_custom_label(self, vlayer):
        num_images_label = QgsPalLayerSettings()
        num_images_label.fieldName = 'num_images_tagged'
        num_images_label.enabled = True

        buffer = QgsTextBufferSettings()
        buffer.setColor(QColor('white'))
        buffer.setEnabled(True)
        buffer.setSize(1)

        textformat = QgsTextFormat()
        textformat.setFont(QFont("Arial", 12))
        textformat.setColor(QColor(0, 0, 255))
        textformat.setBuffer(buffer)

        num_images_label.setFormat(textformat)
        num_images_label.placement = QgsPalLayerSettings.Line
        labeler = QgsVectorLayerSimpleLabeling(num_images_label)
        labeler.requiresAdvancedEffects()

        vlayer.setLabelsEnabled(True)
        vlayer.setLabeling(labeler)
        vlayer.triggerRepaint()
        self.generate_num_tagged_rawimages()
    

    def folderpath(self):
        self.required_fields = {'num_images_tagged':QVariant.Double, 'timestamp':QVariant.String}
        fields_validator(self.required_fields, self.project.vlayer)
        self.images_dir = os.path.realpath(QtWidgets.QFileDialog.getExistingDirectory(self, 'Select the images folder'))
        self.logger(f"Images dir selected: {self.images_dir}")
        if not self.images_dir:
            return None
        self.canvas_logger('Sorting images')
        image_sort_task = QgsTask.fromFunction("Sort Images", sort_images, self.images_dir, self.logger)
        QgsApplication.taskManager().addTask(image_sort_task)
        image_sort_task.statusChanged.connect(lambda sort_task_status: self.sort_task_callback(sort_task_status, image_sort_task))

    def change_image(self):
        print(f"Current image index: {self.image_selector.currentIndex()}")
        print(f"Changed image index: {self.sorted_images[self.image_index]}")
        self.image_index = self.image_selector.currentIndex()
        self.load_image(self.image_index)
        self.marker_info.setText('')

    def load_image(self, image_index):
        self.timestamp.setText(str(self.sorted_timestamps[image_index]))
        self.image_path = self.sorted_images[self.image_index]
        self.image = cv2.imread(self.image_path)
        self.height, self.width, self.channel = self.image.shape
        self.bytesPerLine = 3 * self.width
        qImg = QImage(self.image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
        self.current_image = QtGui.QPixmap(qImg)
        self.viewer.setPhoto(self.current_image)
        # Load temperature map if temperature is enabled
        if self.temperature_toggle.isChecked():
            self.temperature_map = self.get_temperature_map(r'{}'.format(self.image_path))
        else:
            self.temperature_map = None

    def load_nxtimg(self):
        self.image_index += 1
        if self.image_index < 0:
            self.image_index = len(self.sorted_images)-1
        elif self.image_index > len(self.sorted_images)-1:
            self.image_index = 0

        self.image_selector.setCurrentIndex(self.image_index)


    def load_previous(self):
        self.image_index -=1
        if self.image_index < 0:
            self.image_index = len(self.sorted_images)-1
        elif self.image_index > len(self.sorted_images)-1:
            self.image_index = 0

        self.image_selector.setCurrentIndex(self.image_index)


    def draw_box(self, imagecopy, x, y, w=32, h=32, image_w=640, image_h=512):
        x1 = max(int(x-w/2), 0)
        y1 = max(int(y-h/2), 0)
        x2 = min(int(x+w/2), image_w)
        y2 = min(int(y+h/2), image_h)
        image = cv2.rectangle(imagecopy, (x1, y1), (x2, y2), [0, 0, 255], 2, 1)
        image = cv2.drawMarker(imagecopy, (x, y), [0, 255, 0], cv2.MARKER_CROSS, 2, 2)
        return image
    
    def photoClicked(self, pos):
        if self.viewer.dragMode()  == QtWidgets.QGraphicsView.NoDrag:
            print(pos.x(), pos.y())
            self.marker_info.setText('%d, %d' % (pos.x(), pos.y()))
            self.markerlocation = [pos.x(),pos.y()]
            x = pos.x()
            y = pos.y() 
            w = int(self.temp_patch_x.text())
            h = int(self.temp_patch_y.text())
            self.painted_image = self.draw_box(self.image.copy(), x, y, w, h)
            qImg = QImage(self.painted_image.data, self.width, self.height, self.bytesPerLine, QImage.Format_RGB888).rgbSwapped()
            self.current_image = QtGui.QPixmap(qImg)
            self.viewer.setPhoto(self.current_image)
            if self.temperature_toggle.isChecked():
                self.extract_temperature(pos)
        
    def tag_image(self):
        self.project.vlayer.startEditing()
        # Check if there are any selected features
        if self.project.vlayer.selectedFeatures():
            sfeature = self.project.vlayer.selectedFeatures()[-1]
        else:
            *_, sfeature = self.project.vlayer.getFeatures()
        self.project.vlayer.removeSelection()

        if not self.delta_temp.text():
            self.canvas_logger("Invalid image for temperature", level=Qgis.Warning)
            return None

        # Get selected feature details
        uid = sfeature['uid']
        sfeature_image_tagged_info = self.image_tagged_info.get(uid, {})
        image_path = self.sorted_images[self.image_index]
        
        # Tag temperature info if temperature is enabled
        if self.temperature_toggle.isChecked():
            dt = unicode(self.sorted_timestamps[self.image_index].replace(microsecond=0))
            sfeature['timestamp'] = dt
            sfeature['temperature_difference'] = float(self.delta_temp.text())
            sfeature['temperature_min']  = float(self.min_temp)
            sfeature['temperature_max'] = float(self.max_temp)

        # Update num images tagged if the image does not already exist in the feature tagged info
        if image_path not in sfeature_image_tagged_info:
            try:
                num_images_tagged = sfeature['num_images_tagged']
            except KeyError:
                fields_validator(self.required_fields, self.project.vlayer)
                num_images_tagged = sfeature['num_images_tagged']
            if not num_images_tagged:
                sfeature['num_images_tagged'] = 1
            else:
                sfeature['num_images_tagged'] += 1

        # If the same marker location and the same image exists, don't add it again
        if sfeature_image_tagged_info.get(image_path, [0, 0]) != self.markerlocation:        
            sfeature_image_tagged_info[image_path] = self.markerlocation
            print(f"Tagged image info: {self.image_tagged_info}")
        else:
            return None
        # Save sfeature tagged info for later use
        self.image_tagged_info[uid] = sfeature_image_tagged_info
        self.project.vlayer.updateFeature(sfeature)
        # Set the marker location to default [0, 0]
        self.markerlocation = [0, 0]

    def parse_tagged_data(self):
        self.canvas_logger('Saving changes to Sensehawk Core')
        self.project.vlayer.commitChanges()
        self.upload_image_list = []
        aws_tagged_images = {}
        for uid in self.image_tagged_info:
            imgs_info = self.image_tagged_info[uid]
            raw_image = []
            image_num = 0
            for next_image in imgs_info:
                if next_image not in self.upload_image_list:
                    self.upload_image_list.append(next_image)
                image = next_image.split('\\')[-1]
                markerlocation = imgs_info[next_image]
                image_type = 'Thermal Raw Image'
                aws_image = {"location": markerlocation,
                    "service": {'bucket': S3_BUCKET,
                                'key': f'hawkai/{self.projectUid}/IR_rawimage/{image}',
                                'name': 'aws_s3',
                                'stage': 'qgis_plugin',
                                'region': S3_REGION,
                                'filename': f'{image_type} {image_num}.jpg'}}
                image_num += 1 
                raw_image.append(aws_image)

            aws_tagged_images[uid] = raw_image
    
        with open(self.project.geojson_path, 'r') as f:
            file = json.load(f)

        # Saving tagged Geojson for backup
        with open(self.images_dir+f'\\{self.projectUid}_tagged.json', 'w') as p:
            json.dump(file , p)

        # Saving tagged images meta data
        with open(self.images_dir+f'\\{self.projectUid}_image_metadata.json', 'w') as g:
            json.dump(aws_tagged_images, g)

        geojson = {'type':'FeatureCollection','features':[]}
        features = file['features']
        for feature in features:
            mapping_uid  = feature['properties'].get('uid', None)
            if not mapping_uid:
                geojson['features'].append(feature)
                continue
            feature['properties']['raw_images'] += aws_tagged_images.get(mapping_uid, [])
            if 'num_images_tagged' in feature['properties']:
                feature['properties'].pop('num_images_tagged')
            geojson['features'].append(feature)

        self.project.qgis_project.removeMapLayers([self.project.vlayer.id()])
        
        with open(self.project.geojson_path, 'w') as f:
            json.dump(geojson, f)
        qclayer = QgsVectorLayer(self.project.geojson_path, self.project.geojson_path, "ogr")
        self.project.qgis_project.addMapLayer(qclayer)
        # Reload layer styles
        categorize_layer(self.project)
        # trigger cutom label for freshly loaded vlayer
        self.project.vlayer = qclayer
        fields_validator(self.required_fields, self.project.vlayer)
        self.trigger_custom_label(self.project.vlayer)
        self.initiate_upload_process()

    def upload_callback(self, upload_task_status, upload_task):
        if upload_task_status != 3:
            return None
        result = upload_task.returned_values
        print(f"{result['num_images']} uploaded")
        self.project.project_tabs_window.save_project()
        self.canvas_logger("Project geojson saved in SenseHawk App", level=Qgis.Success)
        # Reload service object urls if viewer exists
        if self.therm_tools.therm_viewer_widget:
            self.therm_tools.therm_viewer_widget.generate_service_objects()

    def upload_task(self, get_urls_task_status, get_urls_task):
        if get_urls_task_status != 3:
            return None
        post_urls_data = get_urls_task.returned_values["response"]
        upload_task_inputs = {'imageslist':self.upload_image_list,
                              'projectUid':self.projectUid,
                              'img_dir': self.images_dir,
                              'post_urls_data': post_urls_data}
        upload_task = QgsTask.fromFunction("Upload", upload, upload_task_inputs)
        QgsApplication.taskManager().addTask(upload_task)
        upload_task.statusChanged.connect(lambda upload_task_status: self.upload_callback(upload_task_status, upload_task))

    def initiate_upload_process(self):
        task_inputs = {'imageslist':self.upload_image_list,
                       'projectUid':self.projectUid,
                       'core_token': self.project.core_token,
                       'orgUid': self.project.project_details["organization"]["uid"]}
        get_urls_task = QgsTask.fromFunction("Get post URLs", get_presigned_post_urls, task_inputs)
        QgsApplication.taskManager().addTask(get_urls_task)
        get_urls_task.statusChanged.connect(lambda task_status: self.upload_task(task_status, get_urls_task))

        

