# -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  Therm Tools
#                                  A QGIS plugin
#  This window has access to Tools for Therm application.
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2022-08-25
#         git sha              : $Format:%H$
#         copyright            : (C) 2022 by SenseHawk
#         email                : kiranh@sensehawk.com
#  ***************************************************************************/
#
# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """

from qgis.PyQt.QtCore import Qt
from qgis.PyQt import QtWidgets, uic
from PyQt5.QtCore import QVariant 
import qgis
from qgis.core import QgsMessageLog, Qgis, QgsApplication, QgsTask, QgsFeatureRequest, QgsPoint

from ..event_filters import KeypressFilter, KeypressEmitter, KeypressShortcut, MousepressFilter
from ..sensehawk_apis.core_apis import save_project_geojson, get_project_geojson
from ..sensehawk_apis.sid_apis import detect_solar_issues
from ..windows.autoNumbering import ThermNumberingWidget
from ..windows.ImageTagging import ThermImageTaggingWidget
from ..windows.thermliteQc import ThermliteQcWindow
from ..windows.therm_viewer import ThermViewerDockWidget
from ..tasks import clipRequest
from ..utils import create_custom_label, fields_validator
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QKeySequence

import os
import json
import requests

class ThermToolsWidget(QtWidgets.QWidget):

    def __init__(self, project):
        """Constructor."""
        super(ThermToolsWidget, self).__init__()
        uic.loadUi(os.path.join(os.path.dirname(__file__), 'therm_tools.ui'), self)
        self.logger = project.logger
        self.canvas_logger = project.canvas_logger
        self.project = project
        self.parent = self.project.project_tab
        self.iface = self.project.iface
        self.existing_files = self.project.existing_files
        self.canvas = self.iface.mapCanvas()
        self.StringNumberButton.clicked.connect(self.string_numbering)
        # self.StringNumberButton.clicked.connect(lambda : ThermNumberingWidget(self, self.iface))
        self.imagetaggingButton.clicked.connect(self.ImageTagging)
        self.thermliteQcButton.clicked.connect(self.ThermliteTagging)
        self.viewer_button.clicked.connect(self.therm_viewer)
        self.clipButton.clicked.connect(self.clip_raster)
        self.sidv2_detect_button.clicked.connect(self.sid_detection)
        self.class_maps = self.project.class_maps
        self.core_token = self.project.core_token
        self.project_details = self.project.project_details
        self.numbering_widget = None
        self.imagetagging_widget = None
        self.thermlite_tagging_widget = None
        self.therm_viewer_widget = None
        self.project.docktool_widget.visibilityChanged.connect(lambda x :self.uncheck_buttons(x))
        self.field_names = [field.name() for field in self.project.vlayer.fields()]
        self.custom_label.addItems(self.field_names)
        self.custom_label.setEditable(True)
        self.custom_label.lineEdit().setAlignment(Qt.AlignCenter) 
        self.custom_label.lineEdit().setReadOnly(True)
        self.custom_label.view().setRowHidden(0, True)
        self.custom_label.currentTextChanged.connect(lambda x :self.enable_custom_label(x))
    
    def sid_detection(self):
        org_uid = self.project_details['organization'].get('uid', None)
        url =  f'https://sid.sensehawk.com/detect-solar-issues?organization={org_uid}'
        headers = {'Authorization': f'Token {self.core_token}', 'email_id':self.project.user_email}
        payload = {
                "details": {
                    "projectUID": self.project_details['uid'],
                    },
                    "geojson": {
                    "features": [],
                    "type": "FeatureCollection"
                    }
                }
        imagetag = requests.post(url, json=payload, headers=headers)
        if imagetag.status_code == 200:
            self.tag_button.setChecked(False)
            self.canvas_logger('Queued Successfully.',level=Qgis.Success)


    def enable_custom_label(self, field_name):
        create_custom_label(self.project.vlayer, field_name)


    def uncheck_buttons(self, visibility):
        if visibility :
            pass
        else:
            self.uncheck_all_buttons()
            
    def clipraster_callback(self, clip_status, clip_task):
        if clip_status != 3:
            return None
        result = clip_task.returned_values
        message = result['title']
        res_status = result['res_status']
        if res_status == 202:level = Qgis.Success
        else: level = Qgis.Warning
        self.canvas_logger(f'{message}', level=level)

    def clip_raster(self):
        
        self.uncheck_all_buttons()
        # Do not create the task if there are no clip_boundary features
        features = json.load(open(self.project.geojson_path))["features"]
        clip_boundary_exists = False
        for f in features:
            if f["properties"].get("class_name") == "clip_boundary":
                clip_boundary_exists = True
                break

        if not clip_boundary_exists:
            self.canvas_logger("There are no clip boundaries", level=Qgis.Warning)
            return None
        
        # Ask the user whether to convert orthos to magma or not
        confirmation_widget = self.iface.messageBar().createMessage("Convert clips to magma?")
        yes_button = QtWidgets.QPushButton(confirmation_widget)
        yes_button.setText("Yes")
        yes_button.clicked.connect(lambda: self.start_clip_task(convert_to_magma=True))
        no_button = QtWidgets.QPushButton(confirmation_widget)
        no_button.setText("No")
        no_button.clicked.connect(lambda: self.start_clip_task(convert_to_magma=False))
        confirmation_widget.layout().addWidget(yes_button)
        confirmation_widget.layout().addWidget(no_button)
        self.iface.messageBar().pushWidget(confirmation_widget, Qgis.Info)
    
    def start_clip_task(self, convert_to_magma=False):
        clip_task_input = {'project_details':self.project_details,
                             'geojson_path':self.project.geojson_path,
                             'class_maps':self.class_maps,
                             'core_token':self.core_token,
                             'project_type':'therm',
                             'user_email': self.project.user_email,
                             'convert_to_magma': convert_to_magma}
        
        clip_task = QgsTask.fromFunction("Clip Raster", clipRequest, clip_task_input)
        QgsApplication.taskManager().addTask(clip_task)
        clip_task.statusChanged.connect(lambda clip_status : self.clipraster_callback(clip_status, clip_task))


    def ThermliteTagging(self):
        self.project.active_tool_widget.hide()
        if not self.thermlite_tagging_widget:
            self.thermlite_tagging_widget = ThermliteQcWindow(self, self.project)
        self.project.active_docktool_widget = self.thermlite_tagging_widget
        self.project.docktool_widget.setWidget(self.thermlite_tagging_widget)
        self.project.docktool_widget.setFixedSize(560, 780)        
        self.project.docktool_widget.show()
        self.uncheck_all_buttons()
        self.thermliteQcButton.setChecked(True)
        self.project.active_docktool_widget = self.thermlite_tagging_widget
        if self.therm_viewer_widget:
            self.therm_viewer_widget.disconnect_signal()
        self.enable_docktool_custom_labels()
        
    
    def therm_viewer(self):
        self.project.active_tool_widget.hide()
        if not self.therm_viewer_widget:
            self.therm_viewer_widget = ThermViewerDockWidget(self, self.iface)
        self.project.docktool_widget.setWidget(self.therm_viewer_widget)
        self.project.docktool_widget.setFixedSize(585, 780)
        self.project.docktool_widget.show()
        self.uncheck_all_buttons()
        self.viewer_button.setChecked(True)
        # Setup selection changed signal
        self.project.active_docktool_widget = self.therm_viewer_widget
        self.project.docktool_widget.visibilityChanged.connect(lambda x: self.therm_viewer_widget.toggle_signal_connection(x))
        self.enable_docktool_custom_labels()
        # self.therm_viewer_widget.connect_signal()
        # self.therm_viewer_widget.reload_required_data()

    def string_numbering(self):
        self.project.active_tool_widget.hide()
        if not self.numbering_widget:
            self.numbering_widget = ThermNumberingWidget(self, self.iface)
        self.project.docktool_widget.setWidget(self.numbering_widget)
        self.project.docktool_widget.setFixedSize(450, 780)    
        self.project.docktool_widget.show()
        self.uncheck_all_buttons()
        self.StringNumberButton.setChecked(True)
        if self.therm_viewer_widget:
            self.therm_viewer_widget.disconnect_signal()
        # self.project.vlayer.setLabelsEnabled(False)
        self.enable_docktool_custom_labels(onlylabel=True)
    
    def ImageTagging(self):
        self.project.active_tool_widget.hide()
        if not self.imagetagging_widget:
            self.imagetagging_widget = ThermImageTaggingWidget(self, self.iface)
        self.project.docktool_widget.setWidget(self.imagetagging_widget)
        self.project.docktool_widget.setFixedSize(250, 500)   
        self.project.docktool_widget.show()
        self.uncheck_all_buttons()
        self.imagetaggingButton.setChecked(True)
        if self.therm_viewer_widget:
            self.therm_viewer_widget.disconnect_signal()
        self.project.vlayer.setLabelsEnabled(False)
    
    def enable_docktool_custom_labels(self, onlylabel=None):
        tool_field_map = {'StringNumber':'string_number', 'ManualTagging':'num_images_tagged', 'ThermViewer':'num_images_tagged'}
        for button in self.findChildren(QtWidgets.QPushButton):
            if button.isCheckable():
                if button.isChecked():
                    current_tool =  button.text()
                    field_name = tool_field_map.get(current_tool, 'uid')
                    if onlylabel:
                        self.custom_label.setCurrentText(field_name)
                    else:
                        # index_field = self.field_names.index(field_name)
                        if field_name == "num_images_tagged" :
                            self.generate_num_tagged_rawimages()
                        if current_tool == 'ThermViewer':
                            self.therm_viewer_widget.connect_signal()
                            self.therm_viewer_widget.reload_required_data()
                        
                        # #Disabling tables for thermviewer and manual tagging
                        # if not self.project.table_features:
                        #      self.project.project_details_widget.table_checkbox.setChecked(False)
                                    


    def generate_num_tagged_rawimages(self):
        def generate_image_count(task, obj):
            # validate if fields exists if not create one
            required_fields = {'num_images_tagged':QVariant.Double, 
                                    'timestamp':QVariant.String}
            fields_validator(required_fields, obj.project.vlayer, obj.project.application_type)
            # Get num tagged raw images that already exists in the geojson
            features = json.load(open(obj.project.geojson_path))["features"]
            obj.num_tagged_rawimages = {}
            for feature in features:
                raw_images = feature["properties"].get("raw_images", [])
                if type(raw_images) in [str, type(None)]: raw_images = []
                obj.num_tagged_rawimages[feature["properties"].get("uid", None)] = len(raw_images)
            # Loop through layer features and add num_tagged_rawimages as a field for labeler
            features = obj.project.vlayer.getFeatures()
            for feature in features:
                if feature['class_name'] != 'table':
                    uid = feature["uid"]
                    feature["num_images_tagged"] = obj.num_tagged_rawimages.get(uid, 0)
                    obj.project.vlayer.updateFeature(feature)
            obj.project.vlayer.commitChanges()
            obj.project.vlayer.startEditing()
            return {"task": task.description(),
                    "status":'Num image tagged generated'}
        
        def callback(task, logger, obj):
            returned_values = task.returned_values
            if returned_values:
                status = returned_values["status"]
                obj.custom_label.setCurrentText("num_images_tagged")
                logger(str(status))
            
        gnt = QgsTask.fromFunction("Disable Tables", generate_image_count, self)
        QgsApplication.taskManager().addTask(gnt)
        gnt.statusChanged.connect(lambda: callback(gnt, self.logger, self))


    def uncheck_all_buttons(self):
        for button in self.findChildren(QtWidgets.QPushButton):
            if button.isCheckable():
                button.setChecked(False)

    def detect(self):
        map_angle = self.canvas.rotation()
        self.logger("Map canvas angle: {}".format(map_angle))
        self.logger(str(self.project_details))
        def detect_task(task, detect_task_inputs):
            project_details, angle, core_token, user_email = detect_task_inputs
            status = detect_solar_issues(project_details, angle, core_token, user_email)
            return {"task": task.description(),
                    "status": status.json()}
        def callback(task, logger):
            returned_values = task.returned_values
            if returned_values:
                status = returned_values["status"]
                logger(str(status))

        dt = QgsTask.fromFunction("Detect Solar Issues", detect_task, detect_task_inputs=[self.project_details,
                                                                                          map_angle, self.core_token,
                                                                                          self.load_window.user_email])
        QgsApplication.taskManager().addTask(dt)
        dt.statusChanged.connect(lambda: callback(dt, self.logger))

   
